{"ast":null,"code":"import React__default, { useEffect, useCallback, useReducer, useMemo } from 'react';\nimport { f as format } from './index-7cdd58b8.js';\nimport { getOutgoingMessageState, OutgoingMessageStates } from './utils/message/getOutgoingMessageState.js';\nimport { U as UserProfileProvider } from './UserProfileContext-9cfbab4d.js';\nimport useSendbirdStateContext from './useSendbirdStateContext.js';\nimport { _ as _objectSpread2 } from './_rollupPluginBabelHelpers-6bb0305c.js';\nimport { ChannelStateTypes, ThreadListStateTypes, ParentMessageStateTypes } from './Thread/context/types.js';\nimport { ChannelType } from '@sendbird/chat';\nimport { P as PUBSUB_TOPICS } from './topics-b2b77fb9.js';\nimport { GroupChannelHandler } from '@sendbird/chat/groupChannel';\nimport { u as uuidv4 } from './uuid-1adedf62.js';\nimport { SendingStatus, MessageType, MessageMetaArray } from '@sendbird/chat/message';\nimport { b as VOICE_MESSAGE_FILE_NAME, c as VOICE_MESSAGE_MIME_TYPE, M as META_ARRAY_VOICE_DURATION_KEY, d as META_ARRAY_MESSAGE_TYPE_KEY, e as META_ARRAY_MESSAGE_TYPE_VALUE__VOICE } from './consts-95d8566e.js';\nconst getNicknamesMapFromMembers = function () {\n  let members = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  const nicknamesMap = new Map();\n  for (let memberIndex = 0; memberIndex < members.length; memberIndex += 1) {\n    const {\n      userId,\n      nickname\n    } = members[memberIndex];\n    nicknamesMap.set(userId, nickname);\n  }\n  return nicknamesMap;\n};\nconst getParentMessageFrom = message => {\n  if (!message) {\n    return null;\n  }\n  if (isParentMessage(message)) {\n    return message;\n  }\n  if (isThreadMessage(message)) {\n    return (message === null || message === void 0 ? void 0 : message.parentMessage) || null;\n  }\n  return null;\n};\nconst isParentMessage = message => {\n  return (message === null || message === void 0 ? void 0 : message.parentMessage) === null && typeof (message === null || message === void 0 ? void 0 : message.parentMessageId) === 'number' && !(message !== null && message !== void 0 && message.parentMessageId);\n};\nconst isThreadMessage = message => {\n  return (message === null || message === void 0 ? void 0 : message.parentMessage) !== null && typeof (message === null || message === void 0 ? void 0 : message.parentMessageId) === 'number' && (message === null || message === void 0 ? void 0 : message.parentMessageId) > 0 && (message === null || message === void 0 ? void 0 : message.threadInfo) === null;\n};\nconst isAboutSame = (a, b, px) => Math.abs(a - b) <= px;\nconst isEmpty = val => val === null || val === undefined;\n\n// Some Ids return string and number inconsistently\n// only use to comapre IDs\nfunction compareIds(a, b) {\n  if (isEmpty(a) || isEmpty(b)) {\n    return false;\n  }\n  const aString = a.toString();\n  const bString = b.toString();\n  return aString === bString;\n}\nconst getMessageCreatedAt = message => format(message.createdAt, 'p');\nconst isReadMessage = (channel, message) => getOutgoingMessageState(channel, message) === OutgoingMessageStates.READ;\nconst isSameGroup = (message, comparingMessage, currentChannel) => {\n  var _message$sender, _comparingMessage$sen, _message$sender2, _comparingMessage$sen2;\n  if (!(message && comparingMessage && message.messageType && message.messageType !== 'admin' && comparingMessage.messageType && (comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.messageType) !== 'admin' && message !== null && message !== void 0 && message.sender && comparingMessage !== null && comparingMessage !== void 0 && comparingMessage.sender && message !== null && message !== void 0 && message.createdAt && comparingMessage !== null && comparingMessage !== void 0 && comparingMessage.createdAt && message !== null && message !== void 0 && (_message$sender = message.sender) !== null && _message$sender !== void 0 && _message$sender.userId && comparingMessage !== null && comparingMessage !== void 0 && (_comparingMessage$sen = comparingMessage.sender) !== null && _comparingMessage$sen !== void 0 && _comparingMessage$sen.userId)) {\n    return false;\n  }\n  return (message === null || message === void 0 ? void 0 : message.sendingStatus) === (comparingMessage === null || comparingMessage === void 0 ? void 0 : comparingMessage.sendingStatus) && (message === null || message === void 0 ? void 0 : (_message$sender2 = message.sender) === null || _message$sender2 === void 0 ? void 0 : _message$sender2.userId) === (comparingMessage === null || comparingMessage === void 0 ? void 0 : (_comparingMessage$sen2 = comparingMessage.sender) === null || _comparingMessage$sen2 === void 0 ? void 0 : _comparingMessage$sen2.userId) && getMessageCreatedAt(message) === getMessageCreatedAt(comparingMessage) && isReadMessage(currentChannel, message) === isReadMessage(currentChannel, comparingMessage);\n};\nconst compareMessagesForGrouping = (prevMessage, currMessage, nextMessage, currentChannel, replyType) => {\n  if (replyType === 'THREAD' && currMessage !== null && currMessage !== void 0 && currMessage.threadInfo) {\n    return [false, false];\n  }\n  const sendingStatus = (currMessage === null || currMessage === void 0 ? void 0 : currMessage.sendingStatus) || '';\n  const isAcceptable = sendingStatus !== 'pending' && sendingStatus !== 'failed';\n  return [isSameGroup(prevMessage, currMessage, currentChannel) && isAcceptable, isSameGroup(currMessage, nextMessage, currentChannel) && isAcceptable];\n};\nconst scrollIntoLast = function () {\n  let intialTry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  const MAX_TRIES = 10;\n  const currentTry = intialTry;\n  if (currentTry > MAX_TRIES) {\n    return;\n  }\n  try {\n    const scrollDOM = document.querySelector('.sendbird-thread-ui--scroll');\n    // eslint-disable-next-line no-multi-assign\n    scrollDOM.scrollTop = scrollDOM.scrollHeight;\n  } catch (error) {\n    setTimeout(() => {\n      scrollIntoLast(currentTry + 1);\n    }, 500 * currentTry);\n  }\n};\nconst PREV_THREADS_FETCH_SIZE = 30;\nconst NEXT_THREADS_FETCH_SIZE = 30;\nlet ThreadContextActionTypes = /*#__PURE__*/function (ThreadContextActionTypes) {\n  ThreadContextActionTypes[\"INIT_USER_ID\"] = \"INIT_USER_ID\";\n  ThreadContextActionTypes[\"GET_CHANNEL_START\"] = \"GET_CHANNEL_START\";\n  ThreadContextActionTypes[\"GET_CHANNEL_SUCCESS\"] = \"GET_CHANNEL_SUCCESS\";\n  ThreadContextActionTypes[\"GET_CHANNEL_FAILURE\"] = \"GET_CHANNEL_FAILURE\";\n  ThreadContextActionTypes[\"SET_EMOJI_CONTAINER\"] = \"SET_EMOJI_CONTAINER\";\n  ThreadContextActionTypes[\"GET_PARENT_MESSAGE_START\"] = \"GET_PARENT_MESSAGE_START\";\n  ThreadContextActionTypes[\"GET_PARENT_MESSAGE_SUCCESS\"] = \"GET_PARENT_MESSAGE_SUCCESS\";\n  ThreadContextActionTypes[\"GET_PARENT_MESSAGE_FAILURE\"] = \"GET_PARENT_MESSAGE_FAILURE\";\n  ThreadContextActionTypes[\"INITIALIZE_THREAD_LIST_START\"] = \"INITIALIZE_THREAD_LIST_START\";\n  ThreadContextActionTypes[\"INITIALIZE_THREAD_LIST_SUCCESS\"] = \"INITIALIZE_THREAD_LIST_SUCCESS\";\n  ThreadContextActionTypes[\"INITIALIZE_THREAD_LIST_FAILURE\"] = \"INITIALIZE_THREAD_LIST_FAILURE\";\n  ThreadContextActionTypes[\"GET_PREV_MESSAGES_START\"] = \"GET_PREV_MESSAGES_START\";\n  ThreadContextActionTypes[\"GET_PREV_MESSAGES_SUCESS\"] = \"GET_PREV_MESSAGES_SUCESS\";\n  ThreadContextActionTypes[\"GET_PREV_MESSAGES_FAILURE\"] = \"GET_PREV_MESSAGES_FAILURE\";\n  ThreadContextActionTypes[\"GET_NEXT_MESSAGES_START\"] = \"GET_NEXT_MESSAGES_START\";\n  ThreadContextActionTypes[\"GET_NEXT_MESSAGES_SUCESS\"] = \"GET_NEXT_MESSAGES_SUCESS\";\n  ThreadContextActionTypes[\"GET_NEXT_MESSAGES_FAILURE\"] = \"GET_NEXT_MESSAGES_FAILURE\";\n  ThreadContextActionTypes[\"SEND_MESSAGE_START\"] = \"SEND_MESSAGE_START\";\n  ThreadContextActionTypes[\"SEND_MESSAGE_SUCESS\"] = \"SEND_MESSAGE_SUCESS\";\n  ThreadContextActionTypes[\"SEND_MESSAGE_FAILURE\"] = \"SEND_MESSAGE_FAILURE\";\n  ThreadContextActionTypes[\"RESEND_MESSAGE_START\"] = \"RESEND_MESSAGE_START\";\n  ThreadContextActionTypes[\"ON_MESSAGE_DELETED_BY_REQ_ID\"] = \"ON_MESSAGE_DELETED_BY_REQ_ID\";\n  ThreadContextActionTypes[\"ON_MESSAGE_RECEIVED\"] = \"ON_MESSAGE_RECEIVED\";\n  ThreadContextActionTypes[\"ON_MESSAGE_UPDATED\"] = \"ON_MESSAGE_UPDATED\";\n  ThreadContextActionTypes[\"ON_MESSAGE_DELETED\"] = \"ON_MESSAGE_DELETED\";\n  ThreadContextActionTypes[\"ON_REACTION_UPDATED\"] = \"ON_REACTION_UPDATED\";\n  ThreadContextActionTypes[\"ON_USER_MUTED\"] = \"ON_USER_MUTED\";\n  ThreadContextActionTypes[\"ON_USER_UNMUTED\"] = \"ON_USER_UNMUTED\";\n  ThreadContextActionTypes[\"ON_USER_BANNED\"] = \"ON_USER_BANNED\";\n  ThreadContextActionTypes[\"ON_USER_UNBANNED\"] = \"ON_USER_UNBANNED\";\n  ThreadContextActionTypes[\"ON_USER_LEFT\"] = \"ON_USER_LEFT\";\n  ThreadContextActionTypes[\"ON_CHANNEL_FROZEN\"] = \"ON_CHANNEL_FROZEN\";\n  ThreadContextActionTypes[\"ON_CHANNEL_UNFROZEN\"] = \"ON_CHANNEL_UNFROZEN\";\n  ThreadContextActionTypes[\"ON_OPERATOR_UPDATED\"] = \"ON_OPERATOR_UPDATED\";\n  return ThreadContextActionTypes;\n}({});\nfunction reducer(state, action) {\n  switch (action.type) {\n    // initialize\n    case ThreadContextActionTypes.INIT_USER_ID:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          currentUserId: action.payload\n        });\n      }\n    case ThreadContextActionTypes.GET_CHANNEL_START:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          channelState: ChannelStateTypes.LOADING,\n          currentChannel: null\n        });\n      }\n    case ThreadContextActionTypes.GET_CHANNEL_SUCCESS:\n      {\n        var _groupChannel$members, _groupChannel$members2;\n        const groupChannel = action.payload.groupChannel;\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          channelState: ChannelStateTypes.INITIALIZED,\n          currentChannel: groupChannel,\n          // only support in normal group channel\n          isMuted: (groupChannel === null || groupChannel === void 0 ? void 0 : (_groupChannel$members = groupChannel.members) === null || _groupChannel$members === void 0 ? void 0 : (_groupChannel$members2 = _groupChannel$members.find(member => (member === null || member === void 0 ? void 0 : member.userId) === state.currentUserId)) === null || _groupChannel$members2 === void 0 ? void 0 : _groupChannel$members2.isMuted) || false,\n          isChannelFrozen: (groupChannel === null || groupChannel === void 0 ? void 0 : groupChannel.isFrozen) || false\n        });\n      }\n    case ThreadContextActionTypes.GET_CHANNEL_FAILURE:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          channelState: ChannelStateTypes.INVALID,\n          currentChannel: null\n        });\n      }\n    case ThreadContextActionTypes.SET_EMOJI_CONTAINER:\n      {\n        const {\n          emojiContainer\n        } = action.payload;\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          emojiContainer: emojiContainer\n        });\n      }\n    case ThreadContextActionTypes.GET_PARENT_MESSAGE_START:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          parentMessageState: ParentMessageStateTypes.LOADING,\n          parentMessage: null\n        });\n      }\n    case ThreadContextActionTypes.GET_PARENT_MESSAGE_SUCCESS:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          parentMessageState: ParentMessageStateTypes.INITIALIZED,\n          parentMessage: action.payload.parentMessage\n        });\n      }\n    case ThreadContextActionTypes.GET_PARENT_MESSAGE_FAILURE:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          parentMessageState: ParentMessageStateTypes.INVALID,\n          parentMessage: null\n        });\n      }\n    // fetch threads\n    case ThreadContextActionTypes.INITIALIZE_THREAD_LIST_START:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          threadListState: ThreadListStateTypes.LOADING,\n          allThreadMessages: []\n        });\n      }\n    case ThreadContextActionTypes.INITIALIZE_THREAD_LIST_SUCCESS:\n      {\n        const {\n          parentMessage,\n          anchorMessage,\n          threadedMessages\n        } = action.payload;\n        const anchorMessageCreatedAt = !(anchorMessage !== null && anchorMessage !== void 0 && anchorMessage.messageId) ? parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.createdAt : anchorMessage === null || anchorMessage === void 0 ? void 0 : anchorMessage.createdAt;\n        const anchorIndex = threadedMessages.findIndex(message => (message === null || message === void 0 ? void 0 : message.createdAt) > anchorMessageCreatedAt);\n        const prevThreadMessages = anchorIndex > -1 ? threadedMessages.slice(0, anchorIndex) : threadedMessages;\n        const anchorThreadMessage = anchorMessage !== null && anchorMessage !== void 0 && anchorMessage.messageId ? [anchorMessage] : [];\n        const nextThreadMessages = anchorIndex > -1 ? threadedMessages.slice(anchorIndex) : [];\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          threadListState: ThreadListStateTypes.INITIALIZED,\n          hasMorePrev: anchorIndex === -1 || anchorIndex === PREV_THREADS_FETCH_SIZE,\n          hasMoreNext: threadedMessages.length - anchorIndex === NEXT_THREADS_FETCH_SIZE,\n          allThreadMessages: [prevThreadMessages, anchorThreadMessage, nextThreadMessages].flat()\n        });\n      }\n    case ThreadContextActionTypes.INITIALIZE_THREAD_LIST_FAILURE:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          threadListState: ThreadListStateTypes.INVALID,\n          allThreadMessages: []\n        });\n      }\n    case ThreadContextActionTypes.GET_NEXT_MESSAGES_START:\n      {\n        return _objectSpread2({}, state);\n      }\n    case ThreadContextActionTypes.GET_NEXT_MESSAGES_SUCESS:\n      {\n        const {\n          threadedMessages\n        } = action.payload;\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          hasMoreNext: threadedMessages.length === NEXT_THREADS_FETCH_SIZE,\n          allThreadMessages: [...state.allThreadMessages, ...threadedMessages]\n        });\n      }\n    case ThreadContextActionTypes.GET_NEXT_MESSAGES_FAILURE:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          hasMoreNext: false\n        });\n      }\n    case ThreadContextActionTypes.GET_PREV_MESSAGES_START:\n      {\n        return _objectSpread2({}, state);\n      }\n    case ThreadContextActionTypes.GET_PREV_MESSAGES_SUCESS:\n      {\n        const {\n          threadedMessages\n        } = action.payload;\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          hasMorePrev: threadedMessages.length === PREV_THREADS_FETCH_SIZE,\n          allThreadMessages: [...threadedMessages, ...state.allThreadMessages]\n        });\n      }\n    case ThreadContextActionTypes.GET_PREV_MESSAGES_FAILURE:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          hasMorePrev: false\n        });\n      }\n    // event handlers - message status change\n    case ThreadContextActionTypes.ON_MESSAGE_RECEIVED:\n      {\n        var _state$currentChannel, _message$parentMessag, _state$parentMessage, _state$parentMessage2;\n        const {\n          channel,\n          message\n        } = action.payload;\n        if (((_state$currentChannel = state.currentChannel) === null || _state$currentChannel === void 0 ? void 0 : _state$currentChannel.url) !== (channel === null || channel === void 0 ? void 0 : channel.url) || state.hasMoreNext || (message === null || message === void 0 ? void 0 : (_message$parentMessag = message.parentMessage) === null || _message$parentMessag === void 0 ? void 0 : _message$parentMessag.messageId) !== (state === null || state === void 0 ? void 0 : (_state$parentMessage = state.parentMessage) === null || _state$parentMessage === void 0 ? void 0 : _state$parentMessage.messageId)) {\n          return state;\n        }\n        const isAlreadyReceived = state.allThreadMessages.findIndex(m => m.messageId === message.messageId) > -1;\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          parentMessage: ((_state$parentMessage2 = state.parentMessage) === null || _state$parentMessage2 === void 0 ? void 0 : _state$parentMessage2.messageId) === (message === null || message === void 0 ? void 0 : message.messageId) ? message : state.parentMessage,\n          allThreadMessages: isAlreadyReceived ? state.allThreadMessages.map(m => m.messageId === message.messageId ? message : m) : [...state.allThreadMessages.filter(m => (m === null || m === void 0 ? void 0 : m.reqId) !== (message === null || message === void 0 ? void 0 : message.reqId)), message]\n        });\n      }\n    case ThreadContextActionTypes.ON_MESSAGE_UPDATED:\n      {\n        var _state$currentChannel2, _state$parentMessage3, _state$allThreadMessa;\n        const {\n          channel,\n          message\n        } = action.payload;\n        if (((_state$currentChannel2 = state.currentChannel) === null || _state$currentChannel2 === void 0 ? void 0 : _state$currentChannel2.url) !== (channel === null || channel === void 0 ? void 0 : channel.url)) {\n          return state;\n        }\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          parentMessage: ((_state$parentMessage3 = state.parentMessage) === null || _state$parentMessage3 === void 0 ? void 0 : _state$parentMessage3.messageId) === (message === null || message === void 0 ? void 0 : message.messageId) ? message : state.parentMessage,\n          allThreadMessages: (_state$allThreadMessa = state.allThreadMessages) === null || _state$allThreadMessa === void 0 ? void 0 : _state$allThreadMessa.map(msg => (msg === null || msg === void 0 ? void 0 : msg.messageId) === (message === null || message === void 0 ? void 0 : message.messageId) ? message : msg)\n        });\n      }\n    case ThreadContextActionTypes.ON_MESSAGE_DELETED:\n      {\n        var _state$currentChannel3, _state$parentMessage4, _state$allThreadMessa2;\n        const {\n          channel,\n          messageId\n        } = action.payload;\n        if (((_state$currentChannel3 = state.currentChannel) === null || _state$currentChannel3 === void 0 ? void 0 : _state$currentChannel3.url) !== (channel === null || channel === void 0 ? void 0 : channel.url)) {\n          return state;\n        }\n        if ((state === null || state === void 0 ? void 0 : (_state$parentMessage4 = state.parentMessage) === null || _state$parentMessage4 === void 0 ? void 0 : _state$parentMessage4.messageId) === messageId) {\n          return _objectSpread2(_objectSpread2({}, state), {}, {\n            parentMessage: null,\n            parentMessageState: ParentMessageStateTypes.NIL,\n            allThreadMessages: []\n          });\n        }\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          allThreadMessages: (_state$allThreadMessa2 = state.allThreadMessages) === null || _state$allThreadMessa2 === void 0 ? void 0 : _state$allThreadMessa2.filter(msg => (msg === null || msg === void 0 ? void 0 : msg.messageId) !== messageId)\n        });\n      }\n    case ThreadContextActionTypes.ON_MESSAGE_DELETED_BY_REQ_ID:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          allThreadMessages: state.allThreadMessages.filter(m => !compareIds(m.reqId, action.payload))\n        });\n      }\n    case ThreadContextActionTypes.ON_REACTION_UPDATED:\n      {\n        var _action$payload, _state$parentMessage5;\n        const reactionEvent = (_action$payload = action.payload) === null || _action$payload === void 0 ? void 0 : _action$payload.reactionEvent;\n        if ((state === null || state === void 0 ? void 0 : (_state$parentMessage5 = state.parentMessage) === null || _state$parentMessage5 === void 0 ? void 0 : _state$parentMessage5.messageId) === (reactionEvent === null || reactionEvent === void 0 ? void 0 : reactionEvent.messageId)) {\n          var _state$parentMessage6, _state$parentMessage7;\n          (_state$parentMessage6 = state.parentMessage) === null || _state$parentMessage6 === void 0 ? void 0 : (_state$parentMessage7 = _state$parentMessage6.applyReactionEvent) === null || _state$parentMessage7 === void 0 ? void 0 : _state$parentMessage7.call(_state$parentMessage6, reactionEvent);\n        }\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          allThreadMessages: state.allThreadMessages.map(m => {\n            if ((reactionEvent === null || reactionEvent === void 0 ? void 0 : reactionEvent.messageId) === (m === null || m === void 0 ? void 0 : m.messageId)) {\n              var _m$applyReactionEvent;\n              m === null || m === void 0 ? void 0 : (_m$applyReactionEvent = m.applyReactionEvent) === null || _m$applyReactionEvent === void 0 ? void 0 : _m$applyReactionEvent.call(m, reactionEvent);\n              return m;\n            }\n            return m;\n          })\n        });\n      }\n    // event handlers - user status change\n    case ThreadContextActionTypes.ON_USER_MUTED:\n      {\n        var _state$currentChannel4;\n        const {\n          channel,\n          user\n        } = action.payload;\n        if (((_state$currentChannel4 = state.currentChannel) === null || _state$currentChannel4 === void 0 ? void 0 : _state$currentChannel4.url) !== (channel === null || channel === void 0 ? void 0 : channel.url) || state.currentUserId !== (user === null || user === void 0 ? void 0 : user.userId)) {\n          return state;\n        }\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          isMuted: true\n        });\n      }\n    case ThreadContextActionTypes.ON_USER_UNMUTED:\n      {\n        var _state$currentChannel5;\n        const {\n          channel,\n          user\n        } = action.payload;\n        if (((_state$currentChannel5 = state.currentChannel) === null || _state$currentChannel5 === void 0 ? void 0 : _state$currentChannel5.url) !== (channel === null || channel === void 0 ? void 0 : channel.url) || state.currentUserId !== (user === null || user === void 0 ? void 0 : user.userId)) {\n          return state;\n        }\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          isMuted: false\n        });\n      }\n    case ThreadContextActionTypes.ON_USER_BANNED:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          channelState: ChannelStateTypes.NIL,\n          threadListState: ThreadListStateTypes.NIL,\n          parentMessageState: ParentMessageStateTypes.NIL,\n          currentChannel: null,\n          parentMessage: null,\n          allThreadMessages: [],\n          hasMorePrev: false,\n          hasMoreNext: false\n        });\n      }\n    case ThreadContextActionTypes.ON_USER_UNBANNED:\n      {\n        return _objectSpread2({}, state);\n      }\n    case ThreadContextActionTypes.ON_USER_LEFT:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          channelState: ChannelStateTypes.NIL,\n          threadListState: ThreadListStateTypes.NIL,\n          parentMessageState: ParentMessageStateTypes.NIL,\n          currentChannel: null,\n          parentMessage: null,\n          allThreadMessages: [],\n          hasMorePrev: false,\n          hasMoreNext: false\n        });\n      }\n    // event handler - channel status change\n    case ThreadContextActionTypes.ON_CHANNEL_FROZEN:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          isChannelFrozen: true\n        });\n      }\n    case ThreadContextActionTypes.ON_CHANNEL_UNFROZEN:\n      {\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          isChannelFrozen: false\n        });\n      }\n    case ThreadContextActionTypes.ON_OPERATOR_UPDATED:\n      {\n        var _state$currentChannel6;\n        const {\n          channel\n        } = action.payload;\n        if ((channel === null || channel === void 0 ? void 0 : channel.url) === ((_state$currentChannel6 = state.currentChannel) === null || _state$currentChannel6 === void 0 ? void 0 : _state$currentChannel6.url)) {\n          return _objectSpread2(_objectSpread2({}, state), {}, {\n            currentChannel: channel\n          });\n        }\n        return state;\n      }\n    // message\n    case ThreadContextActionTypes.SEND_MESSAGE_START:\n      {\n        const {\n          message\n        } = action.payload;\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          allThreadMessages: [...state.allThreadMessages, message]\n        });\n      }\n    case ThreadContextActionTypes.SEND_MESSAGE_SUCESS:\n      {\n        const {\n          message\n        } = action.payload;\n        const filteredThreadMessages = state.allThreadMessages.filter(m => !compareIds(m === null || m === void 0 ? void 0 : m.reqId, message === null || message === void 0 ? void 0 : message.reqId));\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          allThreadMessages: [...filteredThreadMessages, message]\n        });\n      }\n    case ThreadContextActionTypes.SEND_MESSAGE_FAILURE:\n      {\n        const {\n          message\n        } = action.payload;\n        return _objectSpread2(_objectSpread2({}, state), {}, {\n          allThreadMessages: state.allThreadMessages.map(m => compareIds(m === null || m === void 0 ? void 0 : m.reqId, message === null || message === void 0 ? void 0 : message.reqId) ? message : m)\n        });\n      }\n    case ThreadContextActionTypes.RESEND_MESSAGE_START:\n      {\n        return _objectSpread2({}, state);\n      }\n    default:\n      {\n        return state;\n      }\n  }\n}\nconst initialState = {\n  currentChannel: null,\n  allThreadMessages: [],\n  parentMessage: null,\n  channelState: ChannelStateTypes.NIL,\n  parentMessageState: ParentMessageStateTypes.NIL,\n  threadListState: ThreadListStateTypes.NIL,\n  hasMorePrev: false,\n  hasMoreNext: false,\n  emojiContainer: {},\n  isMuted: false,\n  isChannelFrozen: false,\n  currentUserId: ''\n};\nfunction useGetChannel(_ref, _ref2) {\n  let {\n    channelUrl,\n    sdkInit,\n    message\n  } = _ref;\n  let {\n    sdk,\n    logger,\n    threadDispatcher\n  } = _ref2;\n  useEffect(() => {\n    // validation check\n    if (sdkInit && channelUrl && sdk !== null && sdk !== void 0 && sdk.groupChannel) {\n      var _sdk$groupChannel$get, _sdk$groupChannel;\n      threadDispatcher({\n        type: ThreadContextActionTypes.GET_CHANNEL_START,\n        payload: null\n      });\n      (_sdk$groupChannel$get = (_sdk$groupChannel = sdk.groupChannel).getChannel) === null || _sdk$groupChannel$get === void 0 ? void 0 : _sdk$groupChannel$get.call(_sdk$groupChannel, channelUrl).then(groupChannel => {\n        logger.info('Thread | useInitialize: Get channel succeeded', groupChannel);\n        threadDispatcher({\n          type: ThreadContextActionTypes.GET_CHANNEL_SUCCESS,\n          payload: {\n            groupChannel\n          }\n        });\n      }).catch(error => {\n        logger.info('Thread | useInitialize: Get channel failed', error);\n        threadDispatcher({\n          type: ThreadContextActionTypes.GET_CHANNEL_FAILURE,\n          payload: error\n        });\n      });\n    }\n  }, [message, sdkInit]);\n  /**\n   * We don't use channelUrl here,\n   * because Thread must operate independently of the channel.\n   */\n}\n\nfunction useGetAllEmoji(_ref, _ref2) {\n  let {\n    sdk\n  } = _ref;\n  let {\n    logger,\n    threadDispatcher\n  } = _ref2;\n  useEffect(() => {\n    if (sdk !== null && sdk !== void 0 && sdk.getAllEmoji) {\n      // validation check\n      sdk === null || sdk === void 0 ? void 0 : sdk.getAllEmoji().then(emojiContainer => {\n        logger.info('Thread | useGetAllEmoji: Getting emojis succeeded.', emojiContainer);\n        threadDispatcher({\n          type: ThreadContextActionTypes.SET_EMOJI_CONTAINER,\n          payload: {\n            emojiContainer\n          }\n        });\n      }).catch(error => {\n        logger.info('Thread | useGetAllEmoji: Getting emojis failed.', error);\n      });\n    }\n  }, [sdk]);\n}\nfunction useGetThreadList(_ref, _ref2) {\n  let {\n    sdkInit,\n    parentMessage,\n    anchorMessage,\n    isReactionEnabled\n  } = _ref;\n  let {\n    logger,\n    threadDispatcher\n  } = _ref2;\n  useEffect(() => {\n    // validation check\n    if (sdkInit && parentMessage !== null && parentMessage !== void 0 && parentMessage.getThreadedMessagesByTimestamp) {\n      var _parentMessage$getThr;\n      threadDispatcher({\n        type: ThreadContextActionTypes.INITIALIZE_THREAD_LIST_START,\n        payload: null\n      });\n      const timeStamp = (anchorMessage === null || anchorMessage === void 0 ? void 0 : anchorMessage.createdAt) || 0;\n      const params = {\n        prevResultSize: PREV_THREADS_FETCH_SIZE,\n        nextResultSize: NEXT_THREADS_FETCH_SIZE,\n        includeReactions: isReactionEnabled,\n        includeMetaArray: true\n      };\n      logger.info('Thread | useGetThreadList: Initialize thread list start.', {\n        timeStamp,\n        params\n      });\n      (_parentMessage$getThr = parentMessage.getThreadedMessagesByTimestamp) === null || _parentMessage$getThr === void 0 ? void 0 : _parentMessage$getThr.call(parentMessage, timeStamp, params).then(_ref3 => {\n        let {\n          parentMessage,\n          threadedMessages\n        } = _ref3;\n        logger.info('Thread | useGetThreadList: Initialize thread list succeeded.', {\n          parentMessage,\n          threadedMessages\n        });\n        threadDispatcher({\n          type: ThreadContextActionTypes.INITIALIZE_THREAD_LIST_SUCCESS,\n          payload: {\n            parentMessage,\n            anchorMessage,\n            threadedMessages\n          }\n        });\n      }).catch(error => {\n        logger.info('Therad | useGetThreadList: Initialize thread list failed.', error);\n        threadDispatcher({\n          type: ThreadContextActionTypes.INITIALIZE_THREAD_LIST_FAILURE,\n          payload: error\n        });\n      });\n    }\n  }, [sdkInit, parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId, anchorMessage]);\n}\nfunction useGetParentMessage(_ref, _ref2) {\n  let {\n    channelUrl,\n    sdkInit,\n    parentMessage\n  } = _ref;\n  let {\n    sdk,\n    logger,\n    threadDispatcher\n  } = _ref2;\n  useEffect(() => {\n    var _sdk$message;\n    // validation check\n    if (sdkInit && sdk !== null && sdk !== void 0 && (_sdk$message = sdk.message) !== null && _sdk$message !== void 0 && _sdk$message.getMessage) {\n      threadDispatcher({\n        type: ThreadContextActionTypes.GET_PARENT_MESSAGE_START,\n        payload: null\n      });\n      const params = {\n        channelUrl,\n        channelType: ChannelType.GROUP,\n        messageId: parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId,\n        includeMetaArray: true,\n        includeReactions: true,\n        includeThreadInfo: true,\n        includeParentMessageInfo: true\n      };\n      logger.info('Thread | useGetParentMessage: Get parent message start.', params);\n      const fetchParentMessage = async () => {\n        var _sdk$message$getMessa, _sdk$message2;\n        const data = await ((_sdk$message$getMessa = (_sdk$message2 = sdk.message).getMessage) === null || _sdk$message$getMessa === void 0 ? void 0 : _sdk$message$getMessa.call(_sdk$message2, params));\n        return data;\n      };\n      fetchParentMessage().then(parentMsg => {\n        logger.info('Thread | useGetParentMessage: Get parent message succeeded.', parentMessage);\n        parentMsg.ogMetaData = (parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.ogMetaData) || null; // ogMetaData is not included for now\n        threadDispatcher({\n          type: ThreadContextActionTypes.GET_PARENT_MESSAGE_SUCCESS,\n          payload: {\n            parentMessage: parentMsg\n          }\n        });\n      }).catch(error => {\n        logger.info('Thread | useGetParentMessage: Get parent message failed.', error);\n        threadDispatcher({\n          type: ThreadContextActionTypes.GET_PARENT_MESSAGE_FAILURE,\n          payload: error\n        });\n      });\n    }\n  }, [sdkInit, parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId]);\n  /**\n   * We don't use channelUrl here,\n   * because Thread must operate independently of the channel.\n   */\n}\n\nfunction useHandlePubsubEvents(_ref, _ref2) {\n  let {\n    sdkInit,\n    currentChannel,\n    parentMessage\n  } = _ref;\n  let {\n    pubSub,\n    threadDispatcher\n  } = _ref2;\n  useEffect(() => {\n    const pubSubHandler = () => {\n      const subscriber = new Map();\n      if (!pubSub || !pubSub.subscribe) {\n        return subscriber;\n      }\n      subscriber.set(PUBSUB_TOPICS.SEND_USER_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.SEND_USER_MESSAGE, props => {\n        const {\n          channel,\n          message\n        } = props;\n        if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url) && (message === null || message === void 0 ? void 0 : message.parentMessageId) === (parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId)) {\n          threadDispatcher({\n            type: ThreadContextActionTypes.SEND_MESSAGE_SUCESS,\n            payload: {\n              message\n            }\n          });\n        }\n        scrollIntoLast === null || scrollIntoLast === void 0 ? void 0 : scrollIntoLast();\n      }));\n      subscriber.set(PUBSUB_TOPICS.SEND_FILE_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.SEND_FILE_MESSAGE, props => {\n        const {\n          channel,\n          message\n        } = props;\n        if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n          threadDispatcher({\n            type: ThreadContextActionTypes.SEND_MESSAGE_SUCESS,\n            payload: {\n              message\n            }\n          });\n        }\n        scrollIntoLast === null || scrollIntoLast === void 0 ? void 0 : scrollIntoLast();\n      }));\n      subscriber.set(PUBSUB_TOPICS.UPDATE_USER_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.UPDATE_USER_MESSAGE, msg => {\n        const {\n          channel,\n          message\n        } = msg;\n        if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_MESSAGE_UPDATED,\n            payload: {\n              channel,\n              message\n            }\n          });\n        }\n      }));\n      subscriber.set(PUBSUB_TOPICS.DELETE_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.DELETE_MESSAGE, msg => {\n        const {\n          channel,\n          messageId\n        } = msg;\n        if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_MESSAGE_DELETED,\n            payload: {\n              messageId\n            }\n          });\n        }\n      }));\n    };\n    const subscriber = pubSubHandler();\n    return () => {\n      subscriber === null || subscriber === void 0 ? void 0 : subscriber.forEach(s => {\n        try {\n          s === null || s === void 0 ? void 0 : s.remove();\n        } catch (_unused) {\n          //\n        }\n      });\n    };\n  }, [sdkInit, currentChannel]);\n}\nfunction useHandleChannelEvents(_ref, _ref2) {\n  let {\n    sdk,\n    currentChannel\n  } = _ref;\n  let {\n    logger,\n    threadDispatcher\n  } = _ref2;\n  useEffect(() => {\n    var _sdk$groupChannel;\n    const handlerId = uuidv4();\n    // validation check\n    if (sdk !== null && sdk !== void 0 && (_sdk$groupChannel = sdk.groupChannel) !== null && _sdk$groupChannel !== void 0 && _sdk$groupChannel.addGroupChannelHandler && currentChannel) {\n      var _sdk$groupChannel$add, _sdk$groupChannel2;\n      const channelHandlerParams = {\n        // message status change\n        onMessageReceived(channel, message) {\n          logger.info('Thread | useHandleChannelEvents: onMessageReceived', {\n            channel,\n            message\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_MESSAGE_RECEIVED,\n            payload: {\n              channel,\n              message\n            }\n          });\n        },\n        onMessageUpdated(channel, message) {\n          logger.info('Thread | useHandleChannelEvents: onMessageUpdated', {\n            channel,\n            message\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_MESSAGE_UPDATED,\n            payload: {\n              channel,\n              message\n            }\n          });\n        },\n        onMessageDeleted(channel, messageId) {\n          logger.info('Thread | useHandleChannelEvents: onMessageDeleted', {\n            channel,\n            messageId\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_MESSAGE_DELETED,\n            payload: {\n              channel,\n              messageId\n            }\n          });\n        },\n        onReactionUpdated(channel, reactionEvent) {\n          logger.info('Thread | useHandleChannelEvents: onReactionUpdated', {\n            channel,\n            reactionEvent\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_REACTION_UPDATED,\n            payload: {\n              channel,\n              reactionEvent\n            }\n          });\n        },\n        // user status change\n        onUserMuted(channel, user) {\n          logger.info('Thread | useHandleChannelEvents: onUserMuted', {\n            channel,\n            user\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_USER_MUTED,\n            payload: {\n              channel,\n              user\n            }\n          });\n        },\n        onUserUnmuted(channel, user) {\n          logger.info('Thread | useHandleChannelEvents: onUserUnmuted', {\n            channel,\n            user\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_USER_UNMUTED,\n            payload: {\n              channel,\n              user\n            }\n          });\n        },\n        onUserBanned(channel, user) {\n          logger.info('Thread | useHandleChannelEvents: onUserBanned', {\n            channel,\n            user\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_USER_BANNED,\n            payload: {\n              channel,\n              user\n            }\n          });\n        },\n        onUserUnbanned(channel, user) {\n          logger.info('Thread | useHandleChannelEvents: onUserUnbanned', {\n            channel,\n            user\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_USER_UNBANNED,\n            payload: {\n              channel,\n              user\n            }\n          });\n        },\n        onUserLeft(channel, user) {\n          logger.info('Thread | useHandleChannelEvents: onUserLeft', {\n            channel,\n            user\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_USER_LEFT,\n            payload: {\n              channel,\n              user\n            }\n          });\n        },\n        // channel status change\n        onChannelFrozen(channel) {\n          logger.info('Thread | useHandleChannelEvents: onChannelFrozen', {\n            channel\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_CHANNEL_FROZEN,\n            payload: {\n              channel\n            }\n          });\n        },\n        onChannelUnfrozen(channel) {\n          logger.info('Thread | useHandleChannelEvents: onChannelUnfrozen', {\n            channel\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_CHANNEL_UNFROZEN,\n            payload: {\n              channel\n            }\n          });\n        },\n        onOperatorUpdated(channel, users) {\n          logger.info('Thread | useHandleChannelEvents: onOperatorUpdated', {\n            channel,\n            users\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_OPERATOR_UPDATED,\n            payload: {\n              channel,\n              users\n            }\n          });\n        }\n      };\n      const channelHandler = new GroupChannelHandler(channelHandlerParams);\n      (_sdk$groupChannel$add = (_sdk$groupChannel2 = sdk.groupChannel).addGroupChannelHandler) === null || _sdk$groupChannel$add === void 0 ? void 0 : _sdk$groupChannel$add.call(_sdk$groupChannel2, handlerId, channelHandler);\n      logger.info('Thread | useHandleChannelEvents: Added channelHandler in Thread', {\n        handlerId,\n        channelHandler\n      });\n    }\n    return () => {\n      var _sdk$groupChannel3;\n      // validation check\n      if (handlerId && sdk !== null && sdk !== void 0 && (_sdk$groupChannel3 = sdk.groupChannel) !== null && _sdk$groupChannel3 !== void 0 && _sdk$groupChannel3.removeGroupChannelHandler) {\n        var _sdk$groupChannel$rem, _sdk$groupChannel4;\n        (_sdk$groupChannel$rem = (_sdk$groupChannel4 = sdk.groupChannel).removeGroupChannelHandler) === null || _sdk$groupChannel$rem === void 0 ? void 0 : _sdk$groupChannel$rem.call(_sdk$groupChannel4, handlerId);\n        logger.info('Thread | useHandleChannelEvents: Removed channelHandler in Thread.', handlerId);\n      }\n    };\n  }, [sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel, currentChannel]);\n}\nfunction useSendFileMessageCallback(_ref, _ref2) {\n  let {\n    currentChannel\n  } = _ref;\n  let {\n    logger,\n    pubSub,\n    threadDispatcher\n  } = _ref2;\n  const sendMessage = useCallback((file, quoteMessage) => {\n    const createParamsDefault = () => {\n      const params = {};\n      params.file = file;\n      if (quoteMessage) {\n        params.isReplyToChannel = true;\n        params.parentMessageId = quoteMessage.messageId;\n      }\n      return params;\n    };\n    const params = createParamsDefault();\n    logger.info('Thread | useSendFileMessageCallback: Sending file message start.', params);\n    currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.sendFileMessage(params).onPending(pendingMessage => {\n      threadDispatcher({\n        type: ThreadContextActionTypes.SEND_MESSAGE_START,\n        payload: {\n          /* pubSub is used instead of messagesDispatcher\n          to avoid redundantly calling `messageActionTypes.SEND_MESSAGEGE_START` */\n          message: _objectSpread2(_objectSpread2({}, pendingMessage), {}, {\n            url: URL.createObjectURL(file),\n            // pending thumbnail message seems to be failed\n            requestState: 'pending'\n          })\n        }\n      });\n      setTimeout(() => scrollIntoLast(), 1000);\n    }).onFailed((error, message) => {\n      message.localUrl = URL.createObjectURL(file);\n      message.file = file;\n      logger.info('Thread | useSendFileMessageCallback: Sending file message failed.', {\n        message,\n        error\n      });\n      threadDispatcher({\n        type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n        payload: {\n          message,\n          error\n        }\n      });\n    }).onSucceeded(message => {\n      logger.info('Thread | useSendFileMessageCallback: Sending file message succeeded.', message);\n      pubSub.publish(PUBSUB_TOPICS.SEND_FILE_MESSAGE, {\n        channel: currentChannel,\n        message: message\n      });\n    });\n  }, [currentChannel]);\n  return sendMessage;\n}\nfunction useUpdateMessageCallback(_ref, _ref2) {\n  let {\n    currentChannel,\n    isMentionEnabled\n  } = _ref;\n  let {\n    logger,\n    pubSub,\n    threadDispatcher\n  } = _ref2;\n  return useCallback(props => {\n    var _currentChannel$updat;\n    const {\n      messageId,\n      message,\n      mentionedUsers,\n      mentionTemplate\n    } = props;\n    const createParamsDefault = () => {\n      const params = {};\n      params.message = message;\n      if (isMentionEnabled && (mentionedUsers === null || mentionedUsers === void 0 ? void 0 : mentionedUsers.length) > 0) {\n        params.mentionedUsers = mentionedUsers;\n      }\n      if (isMentionEnabled && mentionTemplate) {\n        params.mentionedMessageTemplate = mentionTemplate;\n      } else {\n        params.mentionedMessageTemplate = message;\n      }\n      return params;\n    };\n    const params = createParamsDefault();\n    logger.info('Thread | useUpdateMessageCallback: Message update start.', params);\n    currentChannel === null || currentChannel === void 0 ? void 0 : (_currentChannel$updat = currentChannel.updateUserMessage) === null || _currentChannel$updat === void 0 ? void 0 : _currentChannel$updat.call(currentChannel, messageId, params).then(message => {\n      logger.info('Thread | useUpdateMessageCallback: Message update succeeded.', message);\n      threadDispatcher({\n        type: ThreadContextActionTypes.ON_MESSAGE_UPDATED,\n        payload: {\n          channel: currentChannel,\n          message: message\n        }\n      });\n      pubSub.publish(PUBSUB_TOPICS.UPDATE_USER_MESSAGE, {\n        fromSelector: true,\n        channel: currentChannel,\n        message: message\n      });\n    });\n  }, [currentChannel, isMentionEnabled]);\n}\nfunction useDeleteMessageCallback(_ref, _ref2) {\n  let {\n    currentChannel,\n    threadDispatcher\n  } = _ref;\n  let {\n    logger\n  } = _ref2;\n  return useCallback(message => {\n    logger.info('Thread | useDeleteMessageCallback: Deleting message.', message);\n    const {\n      sendingStatus\n    } = message;\n    return new Promise((resolve, reject) => {\n      var _currentChannel$delet;\n      logger.info('Thread | useDeleteMessageCallback: Deleting message requestState:', sendingStatus);\n      // Message is only on local\n      if (sendingStatus === 'failed' || sendingStatus === 'pending') {\n        logger.info('Thread | useDeleteMessageCallback: Deleted message from local:', message);\n        threadDispatcher({\n          type: ThreadContextActionTypes.ON_MESSAGE_DELETED_BY_REQ_ID,\n          payload: message.reqId\n        });\n        resolve(message);\n      }\n      logger.info('Thread | useDeleteMessageCallback: Deleting message from remote:', sendingStatus);\n      currentChannel === null || currentChannel === void 0 ? void 0 : (_currentChannel$delet = currentChannel.deleteMessage) === null || _currentChannel$delet === void 0 ? void 0 : _currentChannel$delet.call(currentChannel, message).then(() => {\n        logger.info('Thread | useDeleteMessageCallback: Deleting message success!', message);\n        threadDispatcher({\n          type: ThreadContextActionTypes.ON_MESSAGE_DELETED,\n          payload: {\n            message,\n            channel: currentChannel\n          }\n        });\n        resolve(message);\n      }).catch(err => {\n        logger.warning('Thread | useDeleteMessageCallback: Deleting message failed!', err);\n        reject(err);\n      });\n    });\n  }, [currentChannel]);\n}\nfunction useGetPrevThreadsCallback(_ref, _ref2) {\n  let {\n    hasMorePrev,\n    parentMessage,\n    threadListState,\n    oldestMessageTimeStamp,\n    isReactionEnabled\n  } = _ref;\n  let {\n    logger,\n    threadDispatcher\n  } = _ref2;\n  return useCallback(callback => {\n    // validation check\n    if (threadListState === ThreadListStateTypes.INITIALIZED && parentMessage !== null && parentMessage !== void 0 && parentMessage.getThreadedMessagesByTimestamp && oldestMessageTimeStamp !== 0) {\n      var _parentMessage$getThr;\n      threadDispatcher({\n        type: ThreadContextActionTypes.GET_PREV_MESSAGES_START,\n        payload: null\n      });\n      (_parentMessage$getThr = parentMessage.getThreadedMessagesByTimestamp) === null || _parentMessage$getThr === void 0 ? void 0 : _parentMessage$getThr.call(parentMessage, oldestMessageTimeStamp, {\n        prevResultSize: PREV_THREADS_FETCH_SIZE,\n        nextResultSize: 0,\n        includeReactions: isReactionEnabled,\n        includeMetaArray: true\n      }).then(_ref3 => {\n        let {\n          parentMessage,\n          threadedMessages\n        } = _ref3;\n        logger.info('Thread | useGetPrevThreadsCallback: Fetch prev threads succeeded.', {\n          parentMessage,\n          threadedMessages\n        });\n        threadDispatcher({\n          type: ThreadContextActionTypes.GET_PREV_MESSAGES_SUCESS,\n          payload: {\n            parentMessage,\n            threadedMessages\n          }\n        });\n        callback(threadedMessages);\n      }).catch(error => {\n        logger.info('Thread | useGetPrevThreadsCallback: Fetch prev threads failed.', error);\n        threadDispatcher({\n          type: ThreadContextActionTypes.GET_PREV_MESSAGES_FAILURE,\n          payload: error\n        });\n      });\n    }\n  }, [hasMorePrev, parentMessage, threadListState, oldestMessageTimeStamp]);\n}\nfunction useGetNextThreadsCallback(_ref, _ref2) {\n  let {\n    hasMoreNext,\n    parentMessage,\n    threadListState,\n    latestMessageTimeStamp,\n    isReactionEnabled\n  } = _ref;\n  let {\n    logger,\n    threadDispatcher\n  } = _ref2;\n  return useCallback(callback => {\n    // validation check\n    if (threadListState === ThreadListStateTypes.INITIALIZED && parentMessage !== null && parentMessage !== void 0 && parentMessage.getThreadedMessagesByTimestamp && latestMessageTimeStamp !== 0) {\n      var _parentMessage$getThr;\n      threadDispatcher({\n        type: ThreadContextActionTypes.GET_NEXT_MESSAGES_START,\n        payload: null\n      });\n      (_parentMessage$getThr = parentMessage.getThreadedMessagesByTimestamp) === null || _parentMessage$getThr === void 0 ? void 0 : _parentMessage$getThr.call(parentMessage, latestMessageTimeStamp, {\n        prevResultSize: 0,\n        nextResultSize: NEXT_THREADS_FETCH_SIZE,\n        includeReactions: isReactionEnabled,\n        includeMetaArray: true\n      }).then(_ref3 => {\n        let {\n          parentMessage,\n          threadedMessages\n        } = _ref3;\n        logger.info('Thread | useGetNextThreadsCallback: Fetch next threads succeeded.', {\n          parentMessage,\n          threadedMessages\n        });\n        threadDispatcher({\n          type: ThreadContextActionTypes.GET_NEXT_MESSAGES_SUCESS,\n          payload: {\n            parentMessage,\n            threadedMessages\n          }\n        });\n        callback(threadedMessages);\n      }).catch(error => {\n        logger.info('Thread | useGetNextThreadsCallback: Fetch next threads failed.', error);\n        threadDispatcher({\n          type: ThreadContextActionTypes.GET_NEXT_MESSAGES_FAILURE,\n          payload: error\n        });\n      });\n    }\n  }, [hasMoreNext, parentMessage, threadListState, latestMessageTimeStamp]);\n}\nfunction useToggleReactionCallback(_ref, _ref2) {\n  let {\n    currentChannel\n  } = _ref;\n  let {\n    logger\n  } = _ref2;\n  return useCallback((message, key, isReacted) => {\n    var _currentChannel$addRe;\n    if (isReacted) {\n      var _currentChannel$delet;\n      currentChannel === null || currentChannel === void 0 ? void 0 : (_currentChannel$delet = currentChannel.deleteReaction) === null || _currentChannel$delet === void 0 ? void 0 : _currentChannel$delet.call(currentChannel, message, key).then(res => {\n        logger.info('Thread | useToggleReactionsCallback: Delete reaction succeeded.', res);\n      }).catch(err => {\n        logger.warning('Thread | useToggleReactionsCallback: Delete reaction failed.', err);\n      });\n      return;\n    }\n    currentChannel === null || currentChannel === void 0 ? void 0 : (_currentChannel$addRe = currentChannel.addReaction) === null || _currentChannel$addRe === void 0 ? void 0 : _currentChannel$addRe.call(currentChannel, message, key).then(res => {\n      logger.info('Thread | useToggleReactionsCallback: Add reaction succeeded.', res);\n    }).catch(err => {\n      logger.warning('Thread | useToggleReactionsCallback: Add reaction failed.', err);\n    });\n  }, [currentChannel]);\n}\nfunction useSendUserMessageCallback(_ref, _ref2) {\n  let {\n    isMentionEnabled,\n    currentChannel\n  } = _ref;\n  let {\n    logger,\n    pubSub,\n    threadDispatcher\n  } = _ref2;\n  const sendMessage = useCallback(props => {\n    const {\n      message,\n      quoteMessage = null,\n      mentionTemplate,\n      mentionedUsers\n    } = props;\n    const createDefaultParams = () => {\n      const params = {};\n      params.message = message;\n      if (isMentionEnabled && (mentionedUsers === null || mentionedUsers === void 0 ? void 0 : mentionedUsers.length) > 0) {\n        params.mentionedUsers = mentionedUsers;\n      }\n      if (isMentionEnabled && mentionTemplate && (mentionedUsers === null || mentionedUsers === void 0 ? void 0 : mentionedUsers.length) > 0) {\n        params.mentionedMessageTemplate = mentionTemplate;\n      }\n      if (quoteMessage) {\n        params.isReplyToChannel = true;\n        params.parentMessageId = quoteMessage.messageId;\n      }\n      return params;\n    };\n    const params = createDefaultParams();\n    logger.info('Thread | useSendUserMessageCallback: Sending user message start.', params);\n    if (currentChannel !== null && currentChannel !== void 0 && currentChannel.sendUserMessage) {\n      currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.sendUserMessage(params).onPending(pendingMessage => {\n        threadDispatcher({\n          type: ThreadContextActionTypes.SEND_MESSAGE_START,\n          payload: {\n            message: pendingMessage\n          }\n        });\n      }).onFailed((error, message) => {\n        logger.info('Thread | useSendUserMessageCallback: Sending user message failed.', {\n          message,\n          error\n        });\n        threadDispatcher({\n          type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n          payload: {\n            error,\n            message\n          }\n        });\n      }).onSucceeded(message => {\n        logger.info('Thread | useSendUserMessageCallback: Sending user message succeeded.', message);\n        threadDispatcher({\n          type: ThreadContextActionTypes.SEND_MESSAGE_SUCESS,\n          payload: {\n            message\n          }\n        });\n        // because Thread doesn't subscribe SEND_USER_MESSAGE\n        pubSub.publish(PUBSUB_TOPICS.SEND_USER_MESSAGE, {\n          channel: currentChannel,\n          message: message\n        });\n      });\n    }\n  }, [isMentionEnabled, currentChannel]);\n  return sendMessage;\n}\nfunction useResendMessageCallback(_ref, _ref2) {\n  let {\n    currentChannel\n  } = _ref;\n  let {\n    logger,\n    pubSub,\n    threadDispatcher\n  } = _ref2;\n  return useCallback(failedMessage => {\n    if (failedMessage !== null && failedMessage !== void 0 && failedMessage.isResendable) {\n      var _failedMessage$isUser, _failedMessage$isFile;\n      failedMessage.sendingStatus = SendingStatus.PENDING;\n      logger.info('Thread | useResendMessageCallback: Resending failedMessage start.', failedMessage);\n      threadDispatcher({\n        type: ThreadContextActionTypes.RESEND_MESSAGE_START,\n        payload: failedMessage\n      });\n      if (failedMessage !== null && failedMessage !== void 0 && (_failedMessage$isUser = failedMessage.isUserMessage) !== null && _failedMessage$isUser !== void 0 && _failedMessage$isUser.call(failedMessage) || (failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.messageType) === MessageType.USER) {\n        currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.resendUserMessage(failedMessage).then(message => {\n          logger.info('Thread | useResendMessageCallback: Resending failedMessage succeeded.', message);\n          threadDispatcher({\n            type: ThreadContextActionTypes.SEND_MESSAGE_SUCESS,\n            payload: {\n              message\n            }\n          });\n          pubSub.publish(PUBSUB_TOPICS.SEND_USER_MESSAGE, {\n            channel: currentChannel,\n            message: message\n          });\n        }).catch(error => {\n          logger.warning('Thread | useResendMessageCallback: Resending failedMessage failed.', error);\n          failedMessage.sendingStatus = SendingStatus.FAILED;\n          threadDispatcher({\n            type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n            payload: {\n              message: failedMessage\n            }\n          });\n        });\n      } else if (failedMessage !== null && failedMessage !== void 0 && (_failedMessage$isFile = failedMessage.isFileMessage) !== null && _failedMessage$isFile !== void 0 && _failedMessage$isFile.call(failedMessage) || (failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.messageType) === MessageType.FILE) {\n        var _currentChannel$resen;\n        currentChannel === null || currentChannel === void 0 ? void 0 : (_currentChannel$resen = currentChannel.resendFileMessage) === null || _currentChannel$resen === void 0 ? void 0 : _currentChannel$resen.call(currentChannel, failedMessage).then(message => {\n          logger.info('Thread | useResendMessageCallback: Resending failedMessage succeeded.', message);\n          threadDispatcher({\n            type: ThreadContextActionTypes.SEND_MESSAGE_SUCESS,\n            payload: {\n              message\n            }\n          });\n        }).catch(error => {\n          logger.warning('Thread | useResendMessageCallback: Resending failedMessage failed.', error);\n          failedMessage.sendingStatus = SendingStatus.FAILED;\n          threadDispatcher({\n            type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n            payload: {\n              message: failedMessage\n            }\n          });\n          pubSub.publish(PUBSUB_TOPICS.SEND_FILE_MESSAGE, {\n            channel: currentChannel,\n            message: failedMessage\n          });\n        });\n      } else {\n        logger.warning('Thread | useResendMessageCallback: Message is not resendable.', failedMessage);\n        failedMessage.sendingStatus = SendingStatus.FAILED;\n        threadDispatcher({\n          type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n          payload: {\n            message: failedMessage\n          }\n        });\n      }\n    }\n  }, [currentChannel]);\n}\nconst useSendVoiceMessageCallback = (_ref, _ref2) => {\n  let {\n    currentChannel,\n    onBeforeSendVoiceMessage\n  } = _ref;\n  let {\n    logger,\n    pubSub,\n    threadDispatcher\n  } = _ref2;\n  const sendMessage = useCallback((file, duration, quoteMessage) => {\n    const messageParams = onBeforeSendVoiceMessage && typeof onBeforeSendVoiceMessage === 'function' ? onBeforeSendVoiceMessage(file, quoteMessage) : {\n      file,\n      fileName: VOICE_MESSAGE_FILE_NAME,\n      mimeType: VOICE_MESSAGE_MIME_TYPE,\n      metaArrays: [new MessageMetaArray({\n        key: META_ARRAY_VOICE_DURATION_KEY,\n        value: [`${duration}`]\n      }), new MessageMetaArray({\n        key: META_ARRAY_MESSAGE_TYPE_KEY,\n        value: [META_ARRAY_MESSAGE_TYPE_VALUE__VOICE]\n      })]\n    };\n    if (quoteMessage) {\n      messageParams.isReplyToChannel = true;\n      messageParams.parentMessageId = quoteMessage.messageId;\n    }\n    logger.info('Thread | useSendVoiceMessageCallback:  Start sending voice message', messageParams);\n    currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.sendFileMessage(messageParams).onPending(pendingMessage => {\n      threadDispatcher({\n        type: ThreadContextActionTypes.SEND_MESSAGE_START,\n        payload: {\n          /* pubSub is used instead of messagesDispatcher\n          to avoid redundantly calling `messageActionTypes.SEND_MESSAGEGE_START` */\n          message: _objectSpread2(_objectSpread2({}, pendingMessage), {}, {\n            url: URL.createObjectURL(file),\n            // pending thumbnail message seems to be failed\n            requestState: 'pending'\n          })\n        }\n      });\n      setTimeout(() => scrollIntoLast(), 1000);\n    }).onFailed((error, message) => {\n      message.localUrl = URL.createObjectURL(file);\n      message.file = file;\n      logger.info('Thread | useSendVoiceMessageCallback: Sending voice message failed.', {\n        message,\n        error\n      });\n      threadDispatcher({\n        type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n        payload: {\n          message,\n          error\n        }\n      });\n    }).onSucceeded(message => {\n      logger.info('Thread | useSendVoiceMessageCallback: Sending voice message succeeded.', message);\n      pubSub.publish(PUBSUB_TOPICS.SEND_FILE_MESSAGE, {\n        channel: currentChannel,\n        message: message\n      });\n    });\n  }, [currentChannel, onBeforeSendVoiceMessage]);\n  return sendMessage;\n};\nconst ThreadContext = /*#__PURE__*/React__default.createContext(null);\nconst ThreadProvider = props => {\n  var _allThreadMessages$, _allThreadMessages;\n  const {\n    children,\n    channelUrl,\n    onHeaderActionClick,\n    onMoveToParentMessage,\n    onBeforeSendVoiceMessage,\n    // User Profile\n    disableUserProfile,\n    renderUserProfile,\n    onUserProfileMessage\n  } = props;\n  const propsMessage = props === null || props === void 0 ? void 0 : props.message;\n  const propsParentMessage = getParentMessageFrom(propsMessage);\n  // Context from SendbirdProvider\n  const globalStore = useSendbirdStateContext();\n  const {\n    stores,\n    config\n  } = globalStore;\n  // // stores\n  const {\n    sdkStore,\n    userStore\n  } = stores;\n  const {\n    sdk\n  } = sdkStore;\n  const {\n    user\n  } = userStore;\n  const sdkInit = sdkStore === null || sdkStore === void 0 ? void 0 : sdkStore.initialized;\n  // // config\n  const {\n    logger,\n    pubSub,\n    replyType,\n    isMentionEnabled,\n    isReactionEnabled\n  } = config;\n\n  // dux of Thread\n  const [threadStore, threadDispatcher] = useReducer(reducer, initialState);\n  const {\n    currentChannel,\n    allThreadMessages,\n    parentMessage,\n    channelState,\n    threadListState,\n    parentMessageState,\n    hasMorePrev,\n    hasMoreNext,\n    emojiContainer,\n    isMuted,\n    isChannelFrozen,\n    currentUserId\n  } = threadStore;\n\n  // Initialization\n  useEffect(() => {\n    threadDispatcher({\n      type: ThreadContextActionTypes.INIT_USER_ID,\n      payload: user === null || user === void 0 ? void 0 : user.userId\n    });\n  }, [user]);\n  useGetChannel({\n    channelUrl,\n    sdkInit,\n    message: propsMessage\n  }, {\n    sdk,\n    logger,\n    threadDispatcher\n  });\n  useGetParentMessage({\n    channelUrl,\n    sdkInit,\n    parentMessage: propsParentMessage\n  }, {\n    sdk,\n    logger,\n    threadDispatcher\n  });\n  useGetThreadList({\n    sdkInit,\n    parentMessage,\n    isReactionEnabled,\n    anchorMessage: (propsMessage === null || propsMessage === void 0 ? void 0 : propsMessage.messageId) !== (propsParentMessage === null || propsParentMessage === void 0 ? void 0 : propsParentMessage.messageId) ? propsMessage : null\n    // anchorMessage should be null when parentMessage doesn't exist\n  }, {\n    logger,\n    threadDispatcher\n  });\n  useGetAllEmoji({\n    sdk\n  }, {\n    logger,\n    threadDispatcher\n  });\n  // Handle channel events\n  useHandleChannelEvents({\n    sdk,\n    currentChannel\n  }, {\n    logger,\n    threadDispatcher\n  });\n  useHandlePubsubEvents({\n    sdkInit,\n    currentChannel,\n    parentMessage\n  }, {\n    logger,\n    pubSub,\n    threadDispatcher\n  });\n\n  // callbacks\n  const fetchPrevThreads = useGetPrevThreadsCallback({\n    hasMorePrev,\n    parentMessage,\n    threadListState,\n    isReactionEnabled,\n    oldestMessageTimeStamp: ((_allThreadMessages$ = allThreadMessages[0]) === null || _allThreadMessages$ === void 0 ? void 0 : _allThreadMessages$.createdAt) || 0\n  }, {\n    logger,\n    threadDispatcher\n  });\n  const fetchNextThreads = useGetNextThreadsCallback({\n    hasMoreNext,\n    parentMessage,\n    threadListState,\n    isReactionEnabled,\n    latestMessageTimeStamp: ((_allThreadMessages = allThreadMessages[allThreadMessages.length - 1]) === null || _allThreadMessages === void 0 ? void 0 : _allThreadMessages.createdAt) || 0\n  }, {\n    logger,\n    threadDispatcher\n  });\n  const toggleReaction = useToggleReactionCallback({\n    currentChannel\n  }, {\n    logger\n  });\n  const sendMessage = useSendUserMessageCallback({\n    isMentionEnabled,\n    currentChannel\n  }, {\n    logger,\n    pubSub,\n    threadDispatcher\n  });\n  const sendFileMessage = useSendFileMessageCallback({\n    currentChannel\n  }, {\n    logger,\n    pubSub,\n    threadDispatcher\n  });\n  const sendVoiceMessage = useSendVoiceMessageCallback({\n    currentChannel,\n    onBeforeSendVoiceMessage\n  }, {\n    logger,\n    pubSub,\n    threadDispatcher\n  });\n  const resendMessage = useResendMessageCallback({\n    currentChannel\n  }, {\n    logger,\n    pubSub,\n    threadDispatcher\n  });\n  const updateMessage = useUpdateMessageCallback({\n    currentChannel,\n    isMentionEnabled\n  }, {\n    logger,\n    pubSub,\n    threadDispatcher\n  });\n  const deleteMessage = useDeleteMessageCallback({\n    currentChannel,\n    threadDispatcher\n  }, {\n    logger\n  });\n\n  // memo\n  const nicknamesMap = useMemo(() => replyType && currentChannel ? getNicknamesMapFromMembers(currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.members) : new Map(), [currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.members]);\n  return /*#__PURE__*/React__default.createElement(ThreadContext.Provider, {\n    value: {\n      // ThreadProviderProps\n      channelUrl,\n      message: propsMessage,\n      onHeaderActionClick,\n      onMoveToParentMessage,\n      // ThreadContextInitialState\n      currentChannel,\n      allThreadMessages,\n      parentMessage,\n      channelState,\n      threadListState,\n      parentMessageState,\n      hasMorePrev,\n      hasMoreNext,\n      emojiContainer,\n      // hooks\n      fetchPrevThreads,\n      fetchNextThreads,\n      toggleReaction,\n      sendMessage,\n      sendFileMessage,\n      sendVoiceMessage,\n      resendMessage,\n      updateMessage,\n      deleteMessage,\n      // context\n      nicknamesMap,\n      isMuted,\n      isChannelFrozen,\n      currentUserId\n    }\n  }, /*#__PURE__*/React__default.createElement(UserProfileProvider, {\n    disableUserProfile: disableUserProfile,\n    renderUserProfile: renderUserProfile,\n    onUserProfileMessage: onUserProfileMessage\n  }, children));\n};\nconst useThreadContext = () => React__default.useContext(ThreadContext);\nexport { ThreadProvider as T, compareMessagesForGrouping as c, isAboutSame as i, useThreadContext as u };","map":{"version":3,"mappings":"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","names":["getNicknamesMapFromMembers","members","nicknamesMap","Map","memberIndex","length","userId","nickname","set","getParentMessageFrom","message","isParentMessage","isThreadMessage","parentMessage","parentMessageId","threadInfo","isAboutSame","a","b","px","Math","abs","isEmpty","val","undefined","compareIds","aString","toString","bString","getMessageCreatedAt","format","createdAt","isReadMessage","channel","getOutgoingMessageState","OutgoingMessageStates","READ","isSameGroup","comparingMessage","currentChannel","messageType","sender","_message$sender","_comparingMessage$sen","sendingStatus","_message$sender2","_comparingMessage$sen2","compareMessagesForGrouping","prevMessage","currMessage","nextMessage","replyType","isAcceptable","scrollIntoLast","intialTry","MAX_TRIES","currentTry","scrollDOM","document","querySelector","scrollTop","scrollHeight","error","setTimeout","PREV_THREADS_FETCH_SIZE","NEXT_THREADS_FETCH_SIZE","ThreadContextActionTypes","reducer","state","action","type","actionTypes","INIT_USER_ID","currentUserId","payload","GET_CHANNEL_START","channelState","ChannelStateTypes","LOADING","GET_CHANNEL_SUCCESS","groupChannel","INITIALIZED","isMuted","_groupChannel$members","find","member","_groupChannel$members2","isChannelFrozen","isFrozen","GET_CHANNEL_FAILURE","INVALID","SET_EMOJI_CONTAINER","emojiContainer","GET_PARENT_MESSAGE_START","parentMessageState","ParentMessageStateTypes","GET_PARENT_MESSAGE_SUCCESS","GET_PARENT_MESSAGE_FAILURE","INITIALIZE_THREAD_LIST_START","threadListState","ThreadListStateTypes","allThreadMessages","INITIALIZE_THREAD_LIST_SUCCESS","anchorMessage","threadedMessages","anchorMessageCreatedAt","messageId","anchorIndex","findIndex","prevThreadMessages","slice","anchorThreadMessage","nextThreadMessages","hasMorePrev","hasMoreNext","flat","INITIALIZE_THREAD_LIST_FAILURE","GET_NEXT_MESSAGES_START","GET_NEXT_MESSAGES_SUCESS","GET_NEXT_MESSAGES_FAILURE","GET_PREV_MESSAGES_START","GET_PREV_MESSAGES_SUCESS","GET_PREV_MESSAGES_FAILURE","ON_MESSAGE_RECEIVED","_state$currentChannel","url","_message$parentMessag","_state$parentMessage","isAlreadyReceived","m","_state$parentMessage2","map","filter","reqId","ON_MESSAGE_UPDATED","_state$currentChannel2","_state$parentMessage3","_state$allThreadMessa","msg","ON_MESSAGE_DELETED","_state$currentChannel3","_state$parentMessage4","NIL","_state$allThreadMessa2","ON_MESSAGE_DELETED_BY_REQ_ID","ON_REACTION_UPDATED","reactionEvent","_action$payload","_state$parentMessage5","_state$parentMessage6","applyReactionEvent","_state$parentMessage7","_m$applyReactionEvent","ON_USER_MUTED","user","_state$currentChannel4","ON_USER_UNMUTED","_state$currentChannel5","ON_USER_BANNED","ON_USER_UNBANNED","ON_USER_LEFT","ON_CHANNEL_FROZEN","ON_CHANNEL_UNFROZEN","ON_OPERATOR_UPDATED","_state$currentChannel6","SEND_MESSAGE_START","SEND_MESSAGE_SUCESS","filteredThreadMessages","SEND_MESSAGE_FAILURE","RESEND_MESSAGE_START","initialState","useGetChannel","channelUrl","sdkInit","sdk","logger","threadDispatcher","useEffect","getChannel","_sdk$groupChannel$get","then","info","catch","useGetAllEmoji","getAllEmoji","useGetThreadList","isReactionEnabled","getThreadedMessagesByTimestamp","timeStamp","params","prevResultSize","nextResultSize","includeReactions","includeMetaArray","_parentMessage$getThr","_ref3","useGetParentMessage","_sdk$message","getMessage","channelType","ChannelType","GROUP","includeThreadInfo","includeParentMessageInfo","fetchParentMessage","data","_sdk$message$getMessa","parentMsg","ogMetaData","useHandlePubsubEvents","pubSub","pubSubHandler","subscriber","subscribe","topics","SEND_USER_MESSAGE","props","SEND_FILE_MESSAGE","UPDATE_USER_MESSAGE","DELETE_MESSAGE","forEach","s","remove","useHandleChannelEvents","handlerId","uuidv4","_sdk$groupChannel","addGroupChannelHandler","channelHandlerParams","onMessageReceived","onMessageUpdated","onMessageDeleted","onReactionUpdated","onUserMuted","onUserUnmuted","onUserBanned","onUserUnbanned","onUserLeft","onChannelFrozen","onChannelUnfrozen","onOperatorUpdated","users","channelHandler","GroupChannelHandler","_sdk$groupChannel$add","_sdk$groupChannel3","removeGroupChannelHandler","_sdk$groupChannel$rem","useSendFileMessageCallback","sendMessage","useCallback","file","quoteMessage","createParamsDefault","isReplyToChannel","sendFileMessage","onPending","pendingMessage","URL","createObjectURL","requestState","onFailed","localUrl","onSucceeded","publish","useUpdateMessageCallback","isMentionEnabled","mentionedUsers","mentionTemplate","mentionedMessageTemplate","updateUserMessage","_currentChannel$updat","fromSelector","useDeleteMessageCallback","Promise","resolve","reject","deleteMessage","_currentChannel$delet","err","warning","useGetPrevThreadsCallback","oldestMessageTimeStamp","callback","useGetNextThreadsCallback","latestMessageTimeStamp","useToggleReactionCallback","key","isReacted","deleteReaction","res","addReaction","_currentChannel$addRe","useSendUserMessageCallback","createDefaultParams","sendUserMessage","useResendMessageCallback","failedMessage","isResendable","SendingStatus","PENDING","isUserMessage","_failedMessage$isUser","MessageType","USER","resendUserMessage","FAILED","isFileMessage","_failedMessage$isFile","FILE","resendFileMessage","_currentChannel$resen","useSendVoiceMessageCallback","onBeforeSendVoiceMessage","duration","messageParams","fileName","VOICE_MESSAGE_FILE_NAME","mimeType","VOICE_MESSAGE_MIME_TYPE","metaArrays","MessageMetaArray","META_ARRAY_VOICE_DURATION_KEY","value","META_ARRAY_MESSAGE_TYPE_KEY","META_ARRAY_MESSAGE_TYPE_VALUE__VOICE","ThreadContext","React","createContext","ThreadProvider","children","onHeaderActionClick","onMoveToParentMessage","disableUserProfile","renderUserProfile","onUserProfileMessage","propsMessage","propsParentMessage","globalStore","useSendbirdStateContext","stores","config","sdkStore","userStore","initialized","threadStore","useReducer","threadReducer","threadInitialState","fetchPrevThreads","_allThreadMessages$","fetchNextThreads","_allThreadMessages","toggleReaction","sendVoiceMessage","resendMessage","updateMessage","useMemo","Provider","UserProfileProvider","useThreadContext","useContext"],"sources":["C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\context\\utils.ts","C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\consts.ts","C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\context\\dux\\actionTypes.ts","C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\context\\dux\\reducer.ts","C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\context\\dux\\initialState.ts","C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\context\\hooks\\useGetChannel.ts","C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\context\\hooks\\useGetAllEmoji.ts","C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\context\\hooks\\useGetThreadList.ts","C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\context\\hooks\\useGetParentMessage.ts","C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\context\\hooks\\useHandlePubsubEvents.ts","C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\context\\hooks\\useHandleChannelEvents.ts","C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\context\\hooks\\useSendFileMessage.ts","C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\context\\hooks\\useUpdateMessageCallback.ts","C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\context\\hooks\\useDeleteMessageCallback.ts","C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\context\\hooks\\useGetPrevThreadsCallback.ts","C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\context\\hooks\\useGetNextThreadsCallback.ts","C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\context\\hooks\\useToggleReactionsCallback.ts","C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\context\\hooks\\useSendUserMessageCallback.ts","C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\context\\hooks\\useResendMessageCallback.ts","C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\context\\hooks\\useSendVoiceMessageCallback.ts","C:\\Users\\\\IdeaProjects\\sendbird-uikit-whatsapp-sample\\node_modules\\@sendbird\\src\\modules\\Thread\\context\\ThreadProvider.tsx"],"sourcesContent":["import format from 'date-fns/format';\nimport { GroupChannel } from '@sendbird/chat/groupChannel';\nimport { BaseMessage, FileMessage, UserMessage } from '@sendbird/chat/message';\nimport { getOutgoingMessageState, OutgoingMessageStates } from '../../../utils/exports/getOutgoingMessageState';\n\nexport const getNicknamesMapFromMembers = (members = []): Map<string, string> => {\n  const nicknamesMap = new Map();\n  for (let memberIndex = 0; memberIndex < members.length; memberIndex += 1) {\n    const { userId, nickname } = members[memberIndex];\n    nicknamesMap.set(userId, nickname);\n  }\n  return nicknamesMap;\n};\n\nexport const getParentMessageFrom = (message: UserMessage | FileMessage | null): UserMessage | FileMessage | BaseMessage | null => {\n  if (!message) {\n    return null;\n  }\n  if (isParentMessage(message)) {\n    return message;\n  }\n  if (isThreadMessage(message)) {\n    return message?.parentMessage || null;\n  }\n  return null;\n};\n\nexport const isParentMessage = (message: UserMessage | FileMessage): boolean => {\n  return (\n    message?.parentMessage === null\n    && typeof message?.parentMessageId === 'number'\n    && !message?.parentMessageId\n  );\n};\n\nexport const isThreadMessage = (message: UserMessage | FileMessage): boolean => {\n  return (\n    message?.parentMessage !== null\n    && typeof message?.parentMessageId === 'number'\n    && message?.parentMessageId > 0\n    && message?.threadInfo === null\n  );\n};\n\nexport const isAboutSame = (a: number, b: number, px: number): boolean => (Math.abs(a - b) <= px);\n\nexport const isEmpty = (val: unknown): boolean => (val === null || val === undefined);\n\n// Some Ids return string and number inconsistently\n// only use to comapre IDs\nexport function compareIds(a: number | string, b: number | string): boolean {\n  if (isEmpty(a) || isEmpty(b)) {\n    return false;\n  }\n  const aString = a.toString();\n  const bString = b.toString();\n  return aString === bString;\n}\n\nexport const getMessageCreatedAt = (message: UserMessage | FileMessage): string => format(message.createdAt, 'p');\nexport const isReadMessage = (channel: GroupChannel, message: UserMessage | FileMessage): boolean => (\n  getOutgoingMessageState(channel, message) === OutgoingMessageStates.READ\n);\nexport const isSameGroup = (\n  message: UserMessage | FileMessage,\n  comparingMessage: UserMessage | FileMessage,\n  currentChannel: GroupChannel,\n): boolean => {\n  if (!(message\n    && comparingMessage\n    && message.messageType\n    && message.messageType !== 'admin'\n    && comparingMessage.messageType\n    && comparingMessage?.messageType !== 'admin'\n    && message?.sender\n    && comparingMessage?.sender\n    && message?.createdAt\n    && comparingMessage?.createdAt\n    && message?.sender?.userId\n    && comparingMessage?.sender?.userId\n  )) {\n    return false;\n  }\n  return (\n    message?.sendingStatus === comparingMessage?.sendingStatus\n    && message?.sender?.userId === comparingMessage?.sender?.userId\n    && getMessageCreatedAt(message) === getMessageCreatedAt(comparingMessage)\n    && isReadMessage(currentChannel, message) === isReadMessage(currentChannel, comparingMessage)\n  );\n};\n\nexport const compareMessagesForGrouping = (\n  prevMessage: UserMessage | FileMessage,\n  currMessage: UserMessage | FileMessage,\n  nextMessage: UserMessage | FileMessage,\n  currentChannel: GroupChannel,\n  replyType: string,\n): [boolean, boolean] => {\n  if (replyType === 'THREAD' && currMessage?.threadInfo) {\n    return [false, false];\n  }\n  const sendingStatus = currMessage?.sendingStatus || '';\n  const isAcceptable = sendingStatus !== 'pending' && sendingStatus !== 'failed';\n  return [\n    isSameGroup(prevMessage, currMessage, currentChannel) && isAcceptable,\n    isSameGroup(currMessage, nextMessage, currentChannel) && isAcceptable,\n  ];\n};\n\nexport const scrollIntoLast = (intialTry = 0): void => {\n  const MAX_TRIES = 10;\n  const currentTry = intialTry;\n  if (currentTry > MAX_TRIES) {\n    return;\n  }\n  try {\n    const scrollDOM = document.querySelector('.sendbird-thread-ui--scroll');\n    // eslint-disable-next-line no-multi-assign\n    scrollDOM.scrollTop = scrollDOM.scrollHeight;\n  } catch (error) {\n    setTimeout(() => {\n      scrollIntoLast(currentTry + 1);\n    }, 500 * currentTry);\n  }\n};\n","export const PREV_THREADS_FETCH_SIZE = 30;\nexport const NEXT_THREADS_FETCH_SIZE = 30;\n","export enum ThreadContextActionTypes {\n  // initialize\n  INIT_USER_ID = 'INIT_USER_ID',\n  // channel\n  GET_CHANNEL_START = 'GET_CHANNEL_START',\n  GET_CHANNEL_SUCCESS = 'GET_CHANNEL_SUCCESS',\n  GET_CHANNEL_FAILURE = 'GET_CHANNEL_FAILURE',\n  // emojis\n  SET_EMOJI_CONTAINER = 'SET_EMOJI_CONTAINER',\n  // parent message\n  GET_PARENT_MESSAGE_START = 'GET_PARENT_MESSAGE_START',\n  GET_PARENT_MESSAGE_SUCCESS = 'GET_PARENT_MESSAGE_SUCCESS',\n  GET_PARENT_MESSAGE_FAILURE = 'GET_PARENT_MESSAGE_FAILURE',\n  // fetch threads\n  INITIALIZE_THREAD_LIST_START = 'INITIALIZE_THREAD_LIST_START',\n  INITIALIZE_THREAD_LIST_SUCCESS = 'INITIALIZE_THREAD_LIST_SUCCESS',\n  INITIALIZE_THREAD_LIST_FAILURE = 'INITIALIZE_THREAD_LIST_FAILURE',\n  GET_PREV_MESSAGES_START = 'GET_PREV_MESSAGES_START',\n  GET_PREV_MESSAGES_SUCESS = 'GET_PREV_MESSAGES_SUCESS',\n  GET_PREV_MESSAGES_FAILURE = 'GET_PREV_MESSAGES_FAILURE',\n  GET_NEXT_MESSAGES_START = 'GET_NEXT_MESSAGES_START',\n  GET_NEXT_MESSAGES_SUCESS = 'GET_NEXT_MESSAGES_SUCESS',\n  GET_NEXT_MESSAGES_FAILURE = 'GET_NEXT_MESSAGES_FAILURE',\n  // handle messages\n  SEND_MESSAGE_START = 'SEND_MESSAGE_START',\n  SEND_MESSAGE_SUCESS = 'SEND_MESSAGE_SUCESS',\n  SEND_MESSAGE_FAILURE = 'SEND_MESSAGE_FAILURE',\n  RESEND_MESSAGE_START = 'RESEND_MESSAGE_START',\n  ON_MESSAGE_DELETED_BY_REQ_ID = 'ON_MESSAGE_DELETED_BY_REQ_ID',\n  // event handlers - message status change\n  ON_MESSAGE_RECEIVED = 'ON_MESSAGE_RECEIVED',\n  ON_MESSAGE_UPDATED = 'ON_MESSAGE_UPDATED',\n  ON_MESSAGE_DELETED = 'ON_MESSAGE_DELETED',\n  ON_REACTION_UPDATED = 'ON_REACTION_UPDATED',\n  // event handlers - user status change\n  ON_USER_MUTED = 'ON_USER_MUTED',\n  ON_USER_UNMUTED = 'ON_USER_UNMUTED',\n  ON_USER_BANNED = 'ON_USER_BANNED',\n  ON_USER_UNBANNED = 'ON_USER_UNBANNED',\n  ON_USER_LEFT = 'ON_USER_LEFT',\n  // event handler - channel status change\n  ON_CHANNEL_FROZEN = 'ON_CHANNEL_FROZEN',\n  ON_CHANNEL_UNFROZEN = 'ON_CHANNEL_UNFROZEN',\n  ON_OPERATOR_UPDATED = 'ON_OPERATOR_UPDATED',\n}\n","import { GroupChannel } from '@sendbird/chat/groupChannel';\nimport { FileMessage, ReactionEvent, UserMessage } from '@sendbird/chat/message';\nimport { NEXT_THREADS_FETCH_SIZE, PREV_THREADS_FETCH_SIZE } from '../../consts';\nimport { ChannelStateTypes, ParentMessageStateTypes, ThreadListStateTypes } from '../../types';\nimport { compareIds } from '../utils';\nimport { ThreadContextActionTypes as actionTypes } from './actionTypes';\nimport { ThreadContextInitialState } from './initialState';\n\ninterface ActionInterface {\n  type: actionTypes;\n  payload?: any;\n}\n\nexport default function reducer(\n  state: ThreadContextInitialState,\n  action: ActionInterface,\n): ThreadContextInitialState {\n  switch (action.type) {\n    // initialize\n    case actionTypes.INIT_USER_ID: {\n      return {\n        ...state,\n        currentUserId: action.payload,\n      };\n    }\n    case actionTypes.GET_CHANNEL_START: {\n      return {\n        ...state,\n        channelState: ChannelStateTypes.LOADING,\n        currentChannel: null,\n      };\n    }\n    case actionTypes.GET_CHANNEL_SUCCESS: {\n      const groupChannel = action.payload.groupChannel as GroupChannel;\n      return {\n        ...state,\n        channelState: ChannelStateTypes.INITIALIZED,\n        currentChannel: groupChannel,\n        // only support in normal group channel\n        isMuted: groupChannel?.members?.find((member) => member?.userId === state.currentUserId)?.isMuted || false,\n        isChannelFrozen: groupChannel?.isFrozen || false,\n      };\n    }\n    case actionTypes.GET_CHANNEL_FAILURE: {\n      return {\n        ...state,\n        channelState: ChannelStateTypes.INVALID,\n        currentChannel: null,\n      };\n    }\n    case actionTypes.SET_EMOJI_CONTAINER: {\n      const { emojiContainer } = action.payload;\n      return {\n        ...state,\n        emojiContainer: emojiContainer,\n      };\n    }\n    case actionTypes.GET_PARENT_MESSAGE_START: {\n      return {\n        ...state,\n        parentMessageState: ParentMessageStateTypes.LOADING,\n        parentMessage: null,\n      };\n    }\n    case actionTypes.GET_PARENT_MESSAGE_SUCCESS: {\n      return {\n        ...state,\n        parentMessageState: ParentMessageStateTypes.INITIALIZED,\n        parentMessage: action.payload.parentMessage,\n      };\n    }\n    case actionTypes.GET_PARENT_MESSAGE_FAILURE: {\n      return {\n        ...state,\n        parentMessageState: ParentMessageStateTypes.INVALID,\n        parentMessage: null,\n      };\n    }\n    // fetch threads\n    case actionTypes.INITIALIZE_THREAD_LIST_START: {\n      return {\n        ...state,\n        threadListState: ThreadListStateTypes.LOADING,\n        allThreadMessages: [],\n      };\n    }\n    case actionTypes.INITIALIZE_THREAD_LIST_SUCCESS: {\n      const { parentMessage, anchorMessage, threadedMessages } = action.payload;\n      const anchorMessageCreatedAt = (!anchorMessage?.messageId) ? parentMessage?.createdAt : anchorMessage?.createdAt;\n      const anchorIndex = threadedMessages.findIndex((message) => message?.createdAt > anchorMessageCreatedAt);\n      const prevThreadMessages = anchorIndex > -1 ? threadedMessages.slice(0, anchorIndex) : threadedMessages;\n      const anchorThreadMessage = anchorMessage?.messageId ? [anchorMessage] : [];\n      const nextThreadMessages = anchorIndex > -1 ? threadedMessages.slice(anchorIndex) : [];\n      return {\n        ...state,\n        threadListState: ThreadListStateTypes.INITIALIZED,\n        hasMorePrev: anchorIndex === -1 || anchorIndex === PREV_THREADS_FETCH_SIZE,\n        hasMoreNext: threadedMessages.length - anchorIndex === NEXT_THREADS_FETCH_SIZE,\n        allThreadMessages: [prevThreadMessages, anchorThreadMessage, nextThreadMessages].flat(),\n      };\n    }\n    case actionTypes.INITIALIZE_THREAD_LIST_FAILURE: {\n      return {\n        ...state,\n        threadListState: ThreadListStateTypes.INVALID,\n        allThreadMessages: [],\n      };\n    }\n    case actionTypes.GET_NEXT_MESSAGES_START: {\n      return {\n        ...state,\n      };\n    }\n    case actionTypes.GET_NEXT_MESSAGES_SUCESS: {\n      const { threadedMessages } = action.payload;\n      return {\n        ...state,\n        hasMoreNext: threadedMessages.length === NEXT_THREADS_FETCH_SIZE,\n        allThreadMessages: [...state.allThreadMessages, ...threadedMessages],\n      };\n    }\n    case actionTypes.GET_NEXT_MESSAGES_FAILURE: {\n      return {\n        ...state,\n        hasMoreNext: false,\n      };\n    }\n    case actionTypes.GET_PREV_MESSAGES_START: {\n      return {\n        ...state,\n      };\n    }\n    case actionTypes.GET_PREV_MESSAGES_SUCESS: {\n      const { threadedMessages } = action.payload;\n      return {\n        ...state,\n        hasMorePrev: threadedMessages.length === PREV_THREADS_FETCH_SIZE,\n        allThreadMessages: [...threadedMessages, ...state.allThreadMessages],\n      };\n    }\n    case actionTypes.GET_PREV_MESSAGES_FAILURE: {\n      return {\n        ...state,\n        hasMorePrev: false,\n      };\n    }\n    // event handlers - message status change\n    case actionTypes.ON_MESSAGE_RECEIVED: {\n      const { channel, message }: { channel: GroupChannel, message: UserMessage | FileMessage } = action.payload;\n\n      if (\n        state.currentChannel?.url !== channel?.url\n        || state.hasMoreNext\n        || message?.parentMessage?.messageId !== state?.parentMessage?.messageId\n      ) {\n        return state;\n      }\n      const isAlreadyReceived = state.allThreadMessages.findIndex((m) => (\n        m.messageId === message.messageId\n      )) > -1;\n      return {\n        ...state,\n        parentMessage: state.parentMessage?.messageId === message?.messageId ? message : state.parentMessage,\n        allThreadMessages: isAlreadyReceived\n          ? state.allThreadMessages.map((m) => (\n            m.messageId === message.messageId ? message : m\n          ))\n          : [\n            ...state.allThreadMessages.filter((m) => (m as UserMessage | FileMessage)?.reqId !== message?.reqId),\n            message,\n          ],\n      };\n    }\n    case actionTypes.ON_MESSAGE_UPDATED: {\n      const { channel, message } = action.payload;\n      if (state.currentChannel?.url !== channel?.url) {\n        return state;\n      }\n      return {\n        ...state,\n        parentMessage: state.parentMessage?.messageId === message?.messageId\n          ? message\n          : state.parentMessage,\n        allThreadMessages: state.allThreadMessages?.map((msg) => (\n          (msg?.messageId === message?.messageId) ? message : msg\n        )),\n      };\n    }\n    case actionTypes.ON_MESSAGE_DELETED: {\n      const { channel, messageId } = action.payload;\n      if (state.currentChannel?.url !== channel?.url) {\n        return state;\n      }\n      if (state?.parentMessage?.messageId === messageId) {\n        return {\n          ...state,\n          parentMessage: null,\n          parentMessageState: ParentMessageStateTypes.NIL,\n          allThreadMessages: [],\n        };\n      }\n      return {\n        ...state,\n        allThreadMessages: state.allThreadMessages?.filter((msg) => (\n          msg?.messageId !== messageId\n        )),\n      };\n    }\n    case actionTypes.ON_MESSAGE_DELETED_BY_REQ_ID: {\n      return {\n        ...state,\n        allThreadMessages: state.allThreadMessages.filter((m) => (\n          !compareIds((m as UserMessage | FileMessage).reqId, action.payload)\n        )),\n      };\n    }\n    case actionTypes.ON_REACTION_UPDATED: {\n      const reactionEvent = action.payload?.reactionEvent as ReactionEvent;\n      if (state?.parentMessage?.messageId === reactionEvent?.messageId) {\n        state.parentMessage?.applyReactionEvent?.(reactionEvent);\n      }\n      return {\n        ...state,\n        allThreadMessages: state.allThreadMessages.map((m) => {\n          if (reactionEvent?.messageId === m?.messageId) {\n            m?.applyReactionEvent?.(reactionEvent);\n            return m;\n          }\n          return m;\n        }),\n      };\n    }\n    // event handlers - user status change\n    case actionTypes.ON_USER_MUTED: {\n      const { channel, user } = action.payload;\n      if (state.currentChannel?.url !== channel?.url || state.currentUserId !== user?.userId) {\n        return state;\n      }\n      return {\n        ...state,\n        isMuted: true,\n      };\n    }\n    case actionTypes.ON_USER_UNMUTED: {\n      const { channel, user } = action.payload;\n      if (state.currentChannel?.url !== channel?.url || state.currentUserId !== user?.userId) {\n        return state;\n      }\n      return {\n        ...state,\n        isMuted: false,\n      };\n    }\n    case actionTypes.ON_USER_BANNED: {\n      return {\n        ...state,\n        channelState: ChannelStateTypes.NIL,\n        threadListState: ThreadListStateTypes.NIL,\n        parentMessageState: ParentMessageStateTypes.NIL,\n        currentChannel: null,\n        parentMessage: null,\n        allThreadMessages: [],\n        hasMorePrev: false,\n        hasMoreNext: false,\n      };\n    }\n    case actionTypes.ON_USER_UNBANNED: {\n      return {\n        ...state,\n      };\n    }\n    case actionTypes.ON_USER_LEFT: {\n      return {\n        ...state,\n        channelState: ChannelStateTypes.NIL,\n        threadListState: ThreadListStateTypes.NIL,\n        parentMessageState: ParentMessageStateTypes.NIL,\n        currentChannel: null,\n        parentMessage: null,\n        allThreadMessages: [],\n        hasMorePrev: false,\n        hasMoreNext: false,\n      };\n    }\n    // event handler - channel status change\n    case actionTypes.ON_CHANNEL_FROZEN: {\n      return {\n        ...state,\n        isChannelFrozen: true,\n      };\n    }\n    case actionTypes.ON_CHANNEL_UNFROZEN: {\n      return {\n        ...state,\n        isChannelFrozen: false,\n      };\n    }\n    case actionTypes.ON_OPERATOR_UPDATED: {\n      const { channel } = action.payload;\n      if (channel?.url === state.currentChannel?.url) {\n        return {\n          ...state,\n          currentChannel: channel,\n        };\n      }\n      return state;\n    }\n    // message\n    case actionTypes.SEND_MESSAGE_START: {\n      const { message } = action.payload;\n      return {\n        ...state,\n        allThreadMessages: [\n          ...state.allThreadMessages,\n          message,\n        ],\n      };\n    }\n    case actionTypes.SEND_MESSAGE_SUCESS: {\n      const { message } = action.payload;\n      const filteredThreadMessages = state.allThreadMessages.filter((m) => (\n        !compareIds((m as UserMessage)?.reqId, message?.reqId)\n      ));\n      return {\n        ...state,\n        allThreadMessages: [\n          ...filteredThreadMessages,\n          message,\n        ],\n      };\n    }\n    case actionTypes.SEND_MESSAGE_FAILURE: {\n      const { message } = action.payload;\n      return {\n        ...state,\n        allThreadMessages: state.allThreadMessages.map((m) => (\n          compareIds((m as UserMessage)?.reqId, message?.reqId)\n            ? message\n            : m\n        )),\n      };\n    }\n    case actionTypes.RESEND_MESSAGE_START: {\n      return {\n        ...state,\n      };\n    }\n    default: {\n      return state;\n    }\n  }\n}\n","import { EmojiContainer } from '@sendbird/chat';\nimport { GroupChannel } from '@sendbird/chat/groupChannel';\nimport { BaseMessage, FileMessage, UserMessage } from '@sendbird/chat/message';\nimport {\n  ChannelStateTypes,\n  ParentMessageStateTypes,\n  ThreadListStateTypes,\n} from '../../types';\n\nexport interface ThreadContextInitialState {\n  currentChannel: GroupChannel;\n  allThreadMessages: Array<BaseMessage>;\n  parentMessage: UserMessage | FileMessage;\n  channelState: ChannelStateTypes;\n  parentMessageState: ParentMessageStateTypes;\n  threadListState: ThreadListStateTypes;\n  hasMorePrev: boolean;\n  hasMoreNext: boolean;\n  emojiContainer: EmojiContainer;\n  isMuted: boolean;\n  isChannelFrozen: boolean;\n  currentUserId: string;\n}\n\nconst initialState: ThreadContextInitialState = {\n  currentChannel: null,\n  allThreadMessages: [],\n  parentMessage: null,\n  channelState: ChannelStateTypes.NIL,\n  parentMessageState: ParentMessageStateTypes.NIL,\n  threadListState: ThreadListStateTypes.NIL,\n  hasMorePrev: false,\n  hasMoreNext: false,\n  emojiContainer: {} as EmojiContainer,\n  isMuted: false,\n  isChannelFrozen: false,\n  currentUserId: '',\n};\n\nexport default initialState;\n","import { useEffect } from 'react';\nimport { SendbirdGroupChat } from '@sendbird/chat/groupChannel';\n\nimport { Logger } from '../../../../lib/SendbirdState';\nimport { ThreadContextActionTypes } from '../dux/actionTypes';\nimport { FileMessage, UserMessage } from '@sendbird/chat/message';\n\ninterface DynamicProps {\n  channelUrl: string;\n  sdkInit: boolean;\n  message: UserMessage | FileMessage;\n}\n\ninterface StaticProps {\n  sdk: SendbirdGroupChat;\n  logger: Logger;\n  threadDispatcher: (props: { type: string, payload?: any }) => void;\n}\n\nexport default function useGetChannel({\n  channelUrl,\n  sdkInit,\n  message,\n}: DynamicProps, {\n  sdk,\n  logger,\n  threadDispatcher,\n}: StaticProps): void {\n  useEffect(() => {\n    // validation check\n    if (sdkInit && channelUrl && sdk?.groupChannel) {\n      threadDispatcher({\n        type: ThreadContextActionTypes.GET_CHANNEL_START,\n        payload: null,\n      });\n      sdk.groupChannel.getChannel?.(channelUrl)\n        .then((groupChannel) => {\n          logger.info('Thread | useInitialize: Get channel succeeded', groupChannel);\n          threadDispatcher({\n            type: ThreadContextActionTypes.GET_CHANNEL_SUCCESS,\n            payload: { groupChannel },\n          });\n        })\n        .catch((error) => {\n          logger.info('Thread | useInitialize: Get channel failed', error);\n          threadDispatcher({\n            type: ThreadContextActionTypes.GET_CHANNEL_FAILURE,\n            payload: error,\n          });\n        });\n    }\n  }, [message, sdkInit]);\n  /**\n   * We don't use channelUrl here,\n   * because Thread must operate independently of the channel.\n   */\n}\n","import { useEffect } from 'react';\nimport { SendbirdGroupChat } from '@sendbird/chat/groupChannel';\nimport { CustomUseReducerDispatcher, Logger } from '../../../../lib/SendbirdState';\nimport { ThreadContextActionTypes } from '../dux/actionTypes';\n\ninterface DanamicPrpos {\n  sdk: SendbirdGroupChat;\n}\ninterface StaticProps {\n  logger: Logger;\n  threadDispatcher: CustomUseReducerDispatcher;\n}\n\nexport default function useGetAllEmoji({\n  sdk,\n}: DanamicPrpos, {\n  logger,\n  threadDispatcher,\n}: StaticProps): void {\n  useEffect(() => {\n    if (sdk?.getAllEmoji) { // validation check\n      sdk?.getAllEmoji()\n        .then((emojiContainer) => {\n          logger.info('Thread | useGetAllEmoji: Getting emojis succeeded.', emojiContainer);\n          threadDispatcher({\n            type: ThreadContextActionTypes.SET_EMOJI_CONTAINER,\n            payload: { emojiContainer },\n          });\n        })\n        .catch((error) => {\n          logger.info('Thread | useGetAllEmoji: Getting emojis failed.', error);\n        });\n    }\n  }, [sdk]);\n}\n","import { useEffect } from 'react';\nimport { CustomUseReducerDispatcher, Logger } from '../../../../lib/SendbirdState';\nimport { FileMessage, ThreadedMessageListParams, UserMessage } from '@sendbird/chat/message';\nimport { ThreadContextActionTypes } from '../dux/actionTypes';\nimport { NEXT_THREADS_FETCH_SIZE, PREV_THREADS_FETCH_SIZE } from '../../consts';\n\ninterface DynamicProps {\n  sdkInit: boolean;\n  parentMessage: UserMessage | FileMessage;\n  anchorMessage?: UserMessage | FileMessage;\n  isReactionEnabled?: boolean;\n}\n\ninterface StaticProps {\n  logger: Logger;\n  threadDispatcher: CustomUseReducerDispatcher;\n}\n\nexport default function useGetThreadList({\n  sdkInit,\n  parentMessage,\n  anchorMessage,\n  isReactionEnabled,\n}: DynamicProps, {\n  logger,\n  threadDispatcher,\n}: StaticProps): void {\n  useEffect(() => {\n    // validation check\n    if (sdkInit && parentMessage?.getThreadedMessagesByTimestamp) {\n      threadDispatcher({\n        type: ThreadContextActionTypes.INITIALIZE_THREAD_LIST_START,\n        payload: null,\n      });\n      const timeStamp = anchorMessage?.createdAt || 0;\n      const params = {\n        prevResultSize: PREV_THREADS_FETCH_SIZE,\n        nextResultSize: NEXT_THREADS_FETCH_SIZE,\n        includeReactions: isReactionEnabled,\n        includeMetaArray: true,\n      } as ThreadedMessageListParams;\n      logger.info('Thread | useGetThreadList: Initialize thread list start.', { timeStamp, params });\n      parentMessage.getThreadedMessagesByTimestamp?.(timeStamp, params)\n        .then(({ parentMessage, threadedMessages }) => {\n          logger.info('Thread | useGetThreadList: Initialize thread list succeeded.', { parentMessage, threadedMessages });\n          threadDispatcher({\n            type: ThreadContextActionTypes.INITIALIZE_THREAD_LIST_SUCCESS,\n            payload: {\n              parentMessage,\n              anchorMessage,\n              threadedMessages,\n            },\n          });\n        })\n        .catch((error) => {\n          logger.info('Therad | useGetThreadList: Initialize thread list failed.', error);\n          threadDispatcher({\n            type: ThreadContextActionTypes.INITIALIZE_THREAD_LIST_FAILURE,\n            payload: error,\n          });\n        });\n    }\n  }, [sdkInit, parentMessage?.messageId, anchorMessage]);\n}\n","import { useEffect } from 'react';\nimport { SendbirdGroupChat } from '@sendbird/chat/groupChannel';\n\nimport { CustomUseReducerDispatcher, Logger } from '../../../../lib/SendbirdState';\nimport { BaseMessage, MessageRetrievalParams } from '@sendbird/chat/message';\nimport { ThreadContextActionTypes } from '../dux/actionTypes';\nimport { ChannelType } from '@sendbird/chat';\n\ninterface DynamicProps {\n  channelUrl: string;\n  sdkInit: boolean;\n  parentMessage?: BaseMessage;\n}\n\ninterface StaticProps {\n  sdk: SendbirdGroupChat;\n  logger: Logger;\n  threadDispatcher: CustomUseReducerDispatcher;\n}\n\nexport default function useGetParentMessage({\n  channelUrl,\n  sdkInit,\n  parentMessage,\n}: DynamicProps, {\n  sdk,\n  logger,\n  threadDispatcher,\n}: StaticProps): void {\n  useEffect(() => {\n    // validation check\n    if (sdkInit && sdk?.message?.getMessage) {\n      threadDispatcher({\n        type: ThreadContextActionTypes.GET_PARENT_MESSAGE_START,\n        payload: null,\n      });\n      const params: MessageRetrievalParams = {\n        channelUrl,\n        channelType: ChannelType.GROUP,\n        messageId: parentMessage?.messageId,\n        includeMetaArray: true,\n        includeReactions: true,\n        includeThreadInfo: true,\n        includeParentMessageInfo: true,\n      };\n      logger.info('Thread | useGetParentMessage: Get parent message start.', params);\n      const fetchParentMessage = async () => {\n        const data = await sdk.message.getMessage?.(params);\n        return data;\n      };\n      fetchParentMessage()\n        .then((parentMsg) => {\n          logger.info('Thread | useGetParentMessage: Get parent message succeeded.', parentMessage);\n          parentMsg.ogMetaData = parentMessage?.ogMetaData || null;// ogMetaData is not included for now\n          threadDispatcher({\n            type: ThreadContextActionTypes.GET_PARENT_MESSAGE_SUCCESS,\n            payload: { parentMessage: parentMsg },\n          });\n        })\n        .catch((error) => {\n          logger.info('Thread | useGetParentMessage: Get parent message failed.', error);\n          threadDispatcher({\n            type: ThreadContextActionTypes.GET_PARENT_MESSAGE_FAILURE,\n            payload: error,\n          });\n        });\n    }\n  }, [sdkInit, parentMessage?.messageId]);\n  /**\n   * We don't use channelUrl here,\n   * because Thread must operate independently of the channel.\n   */\n}\n","import { useEffect } from 'react';\nimport { GroupChannel } from '@sendbird/chat/groupChannel';\nimport { FileMessage, UserMessage } from '@sendbird/chat/message';\n\nimport { CustomUseReducerDispatcher, Logger } from '../../../../lib/SendbirdState';\nimport topics from '../../../../lib/pubSub/topics';\nimport { scrollIntoLast } from '../utils';\nimport { ThreadContextActionTypes } from '../dux/actionTypes';\n\ninterface DynamicProps {\n  sdkInit: boolean;\n  currentChannel: GroupChannel;\n  parentMessage: UserMessage | FileMessage\n}\ninterface StaticProps {\n  logger: Logger;\n  pubSub: any;\n  threadDispatcher: CustomUseReducerDispatcher;\n}\n\nexport default function useHandlePubsubEvents({\n  sdkInit,\n  currentChannel,\n  parentMessage,\n}: DynamicProps, {\n  pubSub,\n  threadDispatcher,\n}: StaticProps): void {\n  useEffect(() => {\n    const pubSubHandler = (): Map<any, any> => {\n      const subscriber = new Map();\n      if (!pubSub || !pubSub.subscribe) {\n        return subscriber;\n      }\n      subscriber.set(topics.SEND_USER_MESSAGE, pubSub.subscribe(topics.SEND_USER_MESSAGE, (props) => {\n        const { channel, message } = props;\n        if (currentChannel?.url === channel?.url\n          && message?.parentMessageId === parentMessage?.messageId\n        ) {\n          threadDispatcher({\n            type: ThreadContextActionTypes.SEND_MESSAGE_SUCESS,\n            payload: { message },\n          });\n        }\n        scrollIntoLast?.();\n      }));\n      subscriber.set(topics.SEND_FILE_MESSAGE, pubSub.subscribe(topics.SEND_FILE_MESSAGE, (props) => {\n        const { channel, message } = props;\n        if (currentChannel?.url === channel?.url) {\n          threadDispatcher({\n            type: ThreadContextActionTypes.SEND_MESSAGE_SUCESS,\n            payload: { message },\n          });\n        }\n        scrollIntoLast?.();\n      }));\n      subscriber.set(topics.UPDATE_USER_MESSAGE, pubSub.subscribe(topics.UPDATE_USER_MESSAGE, (msg) => {\n        const { channel, message } = msg;\n        if (currentChannel?.url === channel?.url) {\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_MESSAGE_UPDATED,\n            payload: { channel, message },\n          });\n        }\n      }));\n      subscriber.set(topics.DELETE_MESSAGE, pubSub.subscribe(topics.DELETE_MESSAGE, (msg) => {\n        const { channel, messageId } = msg;\n        if (currentChannel?.url === channel?.url) {\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_MESSAGE_DELETED,\n            payload: { messageId },\n          });\n        }\n      }));\n    };\n    const subscriber = pubSubHandler();\n    return () => {\n      subscriber?.forEach((s) => {\n        try {\n          s?.remove();\n        } catch {\n          //\n        }\n      });\n    };\n  }, [sdkInit, currentChannel]);\n}\n","import { GroupChannel, GroupChannelHandler, SendbirdGroupChat } from '@sendbird/chat/groupChannel';\nimport { useEffect } from 'react';\nimport { CustomUseReducerDispatcher, Logger } from '../../../../lib/SendbirdState';\nimport uuidv4 from '../../../../utils/uuid';\nimport { ThreadContextActionTypes } from '../dux/actionTypes';\n\ninterface DynamicProps {\n  sdk: SendbirdGroupChat;\n  currentChannel: GroupChannel;\n}\ninterface StaticProps {\n  logger: Logger;\n  threadDispatcher: CustomUseReducerDispatcher;\n}\n\nexport default function useHandleChannelEvents({\n  sdk,\n  currentChannel,\n}: DynamicProps, {\n  logger,\n  threadDispatcher,\n}: StaticProps): void {\n  useEffect(() => {\n    const handlerId = uuidv4();\n    // validation check\n    if (sdk?.groupChannel?.addGroupChannelHandler\n      && currentChannel\n    ) {\n      const channelHandlerParams: GroupChannelHandler = {\n        // message status change\n        onMessageReceived(channel, message) {\n          logger.info('Thread | useHandleChannelEvents: onMessageReceived', { channel, message });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_MESSAGE_RECEIVED,\n            payload: { channel, message },\n          });\n        },\n        onMessageUpdated(channel, message) {\n          logger.info('Thread | useHandleChannelEvents: onMessageUpdated', { channel, message });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_MESSAGE_UPDATED,\n            payload: { channel, message },\n          });\n        },\n        onMessageDeleted(channel, messageId) {\n          logger.info('Thread | useHandleChannelEvents: onMessageDeleted', { channel, messageId });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_MESSAGE_DELETED,\n            payload: { channel, messageId },\n          });\n        },\n        onReactionUpdated(channel, reactionEvent) {\n          logger.info('Thread | useHandleChannelEvents: onReactionUpdated', { channel, reactionEvent });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_REACTION_UPDATED,\n            payload: { channel, reactionEvent },\n          });\n        },\n        // user status change\n        onUserMuted(channel, user) {\n          logger.info('Thread | useHandleChannelEvents: onUserMuted', { channel, user });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_USER_MUTED,\n            payload: { channel, user },\n          });\n        },\n        onUserUnmuted(channel, user) {\n          logger.info('Thread | useHandleChannelEvents: onUserUnmuted', { channel, user });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_USER_UNMUTED,\n            payload: { channel, user },\n          });\n        },\n        onUserBanned(channel, user) {\n          logger.info('Thread | useHandleChannelEvents: onUserBanned', { channel, user });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_USER_BANNED,\n            payload: { channel, user },\n          });\n        },\n        onUserUnbanned(channel, user) {\n          logger.info('Thread | useHandleChannelEvents: onUserUnbanned', { channel, user });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_USER_UNBANNED,\n            payload: { channel, user },\n          });\n        },\n        onUserLeft(channel, user) {\n          logger.info('Thread | useHandleChannelEvents: onUserLeft', { channel, user });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_USER_LEFT,\n            payload: { channel, user },\n          });\n        },\n        // channel status change\n        onChannelFrozen(channel) {\n          logger.info('Thread | useHandleChannelEvents: onChannelFrozen', { channel });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_CHANNEL_FROZEN,\n            payload: { channel },\n          });\n        },\n        onChannelUnfrozen(channel) {\n          logger.info('Thread | useHandleChannelEvents: onChannelUnfrozen', { channel });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_CHANNEL_UNFROZEN,\n            payload: { channel },\n          });\n        },\n        onOperatorUpdated(channel, users) {\n          logger.info('Thread | useHandleChannelEvents: onOperatorUpdated', { channel, users });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_OPERATOR_UPDATED,\n            payload: { channel, users },\n          });\n        },\n      };\n      const channelHandler = new GroupChannelHandler(channelHandlerParams);\n      sdk.groupChannel.addGroupChannelHandler?.(handlerId, channelHandler);\n      logger.info('Thread | useHandleChannelEvents: Added channelHandler in Thread', { handlerId, channelHandler });\n    }\n    return () => {\n      // validation check\n      if (handlerId && sdk?.groupChannel?.removeGroupChannelHandler) {\n        sdk.groupChannel.removeGroupChannelHandler?.(handlerId);\n        logger.info('Thread | useHandleChannelEvents: Removed channelHandler in Thread.', handlerId);\n      }\n    };\n  }, [\n    sdk?.groupChannel,\n    currentChannel,\n  ]);\n}\n","import { useCallback } from 'react';\nimport { GroupChannel } from '@sendbird/chat/groupChannel';\nimport { FileMessage, FileMessageCreateParams } from '@sendbird/chat/message';\n\nimport { CustomUseReducerDispatcher, Logger } from '../../../../lib/SendbirdState';\nimport { ThreadContextActionTypes } from '../dux/actionTypes';\nimport topics from '../../../../lib/pubSub/topics';\nimport { scrollIntoLast } from '../utils';\n\ninterface DynamicProps {\n  currentChannel: GroupChannel;\n}\ninterface StaticProps {\n  logger: Logger;\n  pubSub: any;\n  threadDispatcher: CustomUseReducerDispatcher;\n}\n\ninterface LocalFileMessage extends FileMessage {\n  localUrl: string;\n  file: File;\n}\n\nexport default function useSendFileMessageCallback({\n  currentChannel,\n}: DynamicProps, {\n  logger,\n  pubSub,\n  threadDispatcher,\n}: StaticProps): (file, quoteMessage) => void {\n  const sendMessage = useCallback((file, quoteMessage) => {\n    const createParamsDefault = () => {\n      const params = {} as FileMessageCreateParams;\n      params.file = file;\n      if (quoteMessage) {\n        params.isReplyToChannel = true;\n        params.parentMessageId = quoteMessage.messageId;\n      }\n      return params;\n    };\n    const params = createParamsDefault();\n    logger.info('Thread | useSendFileMessageCallback: Sending file message start.', params);\n\n    currentChannel?.sendFileMessage(params)\n      .onPending((pendingMessage) => {\n        threadDispatcher({\n          type: ThreadContextActionTypes.SEND_MESSAGE_START,\n          payload: {\n            /* pubSub is used instead of messagesDispatcher\n            to avoid redundantly calling `messageActionTypes.SEND_MESSAGEGE_START` */\n            message: {\n              ...pendingMessage,\n              url: URL.createObjectURL(file),\n              // pending thumbnail message seems to be failed\n              requestState: 'pending',\n            },\n          },\n        });\n        setTimeout(() => scrollIntoLast(), 1000);\n      })\n      .onFailed((error, message) => {\n        (message as LocalFileMessage).localUrl = URL.createObjectURL(file);\n        (message as LocalFileMessage).file = file;\n        logger.info('Thread | useSendFileMessageCallback: Sending file message failed.', { message, error });\n        threadDispatcher({\n          type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n          payload: { message, error },\n        });\n      })\n      .onSucceeded((message) => {\n        logger.info('Thread | useSendFileMessageCallback: Sending file message succeeded.', message);\n        pubSub.publish(topics.SEND_FILE_MESSAGE, {\n          channel: currentChannel,\n          message: message,\n        });\n      });\n  }, [currentChannel]);\n  return sendMessage;\n}\n","import { useCallback } from 'react';\nimport { GroupChannel } from '@sendbird/chat/groupChannel';\nimport { UserMessage, UserMessageUpdateParams } from '@sendbird/chat/message';\n\nimport { CustomUseReducerDispatcher, Logger } from '../../../../lib/SendbirdState';\nimport { ThreadContextActionTypes } from '../dux/actionTypes';\n\nimport topics from '../../../../lib/pubSub/topics';\n\ninterface DynamicProps {\n  currentChannel: GroupChannel;\n  isMentionEnabled?: boolean;\n}\ninterface StaticProps {\n  logger: Logger;\n  pubSub: any;\n  threadDispatcher: CustomUseReducerDispatcher;\n}\n\nexport default function useUpdateMessageCallback({\n  currentChannel,\n  isMentionEnabled,\n}: DynamicProps, {\n  logger,\n  pubSub,\n  threadDispatcher,\n}: StaticProps): (props) => void {\n  return useCallback((props) => {\n    const {\n      messageId,\n      message,\n      mentionedUsers,\n      mentionTemplate,\n    } = props;\n    const createParamsDefault = () => {\n      const params = {} as UserMessageUpdateParams;\n      params.message = message;\n      if (isMentionEnabled && mentionedUsers?.length > 0) {\n        params.mentionedUsers = mentionedUsers;\n      }\n      if (isMentionEnabled && mentionTemplate) {\n        params.mentionedMessageTemplate = mentionTemplate;\n      } else {\n        params.mentionedMessageTemplate = message;\n      }\n      return params;\n    };\n\n    const params = createParamsDefault();\n    logger.info('Thread | useUpdateMessageCallback: Message update start.', params);\n\n    currentChannel?.updateUserMessage?.(messageId, params)\n      .then((message: UserMessage) => {\n        logger.info('Thread | useUpdateMessageCallback: Message update succeeded.', message);\n        threadDispatcher({\n          type: ThreadContextActionTypes.ON_MESSAGE_UPDATED,\n          payload: {\n            channel: currentChannel,\n            message: message,\n          },\n        });\n        pubSub.publish(\n          topics.UPDATE_USER_MESSAGE,\n          {\n            fromSelector: true,\n            channel: currentChannel,\n            message: message,\n          },\n        );\n      });\n  }, [currentChannel, isMentionEnabled]);\n}\n","import { GroupChannel } from '@sendbird/chat/groupChannel';\nimport { FileMessage, UserMessage } from '@sendbird/chat/message';\nimport { useCallback } from 'react';\nimport { CustomUseReducerDispatcher, Logger } from '../../../../lib/SendbirdState';\nimport { ThreadContextActionTypes } from '../dux/actionTypes';\n\ninterface DynamicProps {\n  currentChannel: GroupChannel;\n  threadDispatcher: CustomUseReducerDispatcher;\n}\ninterface StaticProps {\n  logger: Logger;\n}\n\nexport default function useDeleteMessageCallback({\n  currentChannel,\n  threadDispatcher,\n}: DynamicProps, {\n  logger,\n}: StaticProps): (message: UserMessage | FileMessage) => Promise<UserMessage | FileMessage> {\n  return useCallback((message: UserMessage | FileMessage): Promise<UserMessage | FileMessage> => {\n    logger.info('Thread | useDeleteMessageCallback: Deleting message.', message);\n    const { sendingStatus } = message;\n    return new Promise((resolve, reject) => {\n      logger.info('Thread | useDeleteMessageCallback: Deleting message requestState:', sendingStatus);\n      // Message is only on local\n      if (sendingStatus === 'failed' || sendingStatus === 'pending') {\n        logger.info('Thread | useDeleteMessageCallback: Deleted message from local:', message);\n        threadDispatcher({\n          type: ThreadContextActionTypes.ON_MESSAGE_DELETED_BY_REQ_ID,\n          payload: message.reqId,\n        });\n        resolve(message);\n      }\n\n      logger.info('Thread | useDeleteMessageCallback: Deleting message from remote:', sendingStatus);\n      currentChannel?.deleteMessage?.(message)\n        .then(() => {\n          logger.info('Thread | useDeleteMessageCallback: Deleting message success!', message);\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_MESSAGE_DELETED,\n            payload: { message, channel: currentChannel },\n          });\n          resolve(message);\n        })\n        .catch((err) => {\n          logger.warning('Thread | useDeleteMessageCallback: Deleting message failed!', err);\n          reject(err);\n        });\n    });\n  }, [currentChannel]);\n}\n","import { useCallback } from 'react';\nimport { BaseMessage, FileMessage, ThreadedMessageListParams, UserMessage } from '@sendbird/chat/message';\n\nimport { CustomUseReducerDispatcher, Logger } from '../../../../lib/SendbirdState';\nimport { PREV_THREADS_FETCH_SIZE } from '../../consts';\nimport { ThreadListStateTypes } from '../../types';\nimport { ThreadContextActionTypes } from '../dux/actionTypes';\n\ninterface DynamicProps {\n  hasMorePrev: boolean;\n  parentMessage: UserMessage | FileMessage;\n  threadListState: ThreadListStateTypes;\n  oldestMessageTimeStamp: number;\n  isReactionEnabled?: boolean;\n}\ninterface StaticProps {\n  logger: Logger;\n  threadDispatcher: CustomUseReducerDispatcher;\n}\n\nexport default function useGetPrevThreadsCallback({\n  hasMorePrev,\n  parentMessage,\n  threadListState,\n  oldestMessageTimeStamp,\n  isReactionEnabled,\n}: DynamicProps, {\n  logger,\n  threadDispatcher,\n}: StaticProps): (callback?: (messages?: Array<BaseMessage>) => void) => void {\n  return useCallback((callback) => {\n    // validation check\n    if (threadListState === ThreadListStateTypes.INITIALIZED\n      && parentMessage?.getThreadedMessagesByTimestamp\n      && oldestMessageTimeStamp !== 0\n    ) {\n      threadDispatcher({\n        type: ThreadContextActionTypes.GET_PREV_MESSAGES_START,\n        payload: null,\n      });\n      parentMessage.getThreadedMessagesByTimestamp?.(\n        oldestMessageTimeStamp,\n        {\n          prevResultSize: PREV_THREADS_FETCH_SIZE,\n          nextResultSize: 0,\n          includeReactions: isReactionEnabled,\n          includeMetaArray: true,\n        } as ThreadedMessageListParams,\n      )\n        .then(({ parentMessage, threadedMessages }) => {\n          logger.info('Thread | useGetPrevThreadsCallback: Fetch prev threads succeeded.', { parentMessage, threadedMessages });\n          threadDispatcher({\n            type: ThreadContextActionTypes.GET_PREV_MESSAGES_SUCESS,\n            payload: { parentMessage, threadedMessages },\n          });\n          callback(threadedMessages);\n        })\n        .catch((error) => {\n          logger.info('Thread | useGetPrevThreadsCallback: Fetch prev threads failed.', error);\n          threadDispatcher({\n            type: ThreadContextActionTypes.GET_PREV_MESSAGES_FAILURE,\n            payload: error,\n          });\n        });\n    }\n  }, [\n    hasMorePrev,\n    parentMessage,\n    threadListState,\n    oldestMessageTimeStamp,\n  ]);\n}\n","import { BaseMessage, FileMessage, ThreadedMessageListParams, UserMessage } from '@sendbird/chat/message';\nimport { useCallback } from 'react';\nimport { CustomUseReducerDispatcher, Logger } from '../../../../lib/SendbirdState';\nimport { NEXT_THREADS_FETCH_SIZE } from '../../consts';\nimport { ThreadListStateTypes } from '../../types';\nimport { ThreadContextActionTypes } from '../dux/actionTypes';\n\ninterface DynamicProps {\n  hasMoreNext: boolean;\n  parentMessage: UserMessage | FileMessage;\n  threadListState: ThreadListStateTypes;\n  latestMessageTimeStamp: number;\n  isReactionEnabled?: boolean;\n}\ninterface StaticProps {\n  logger: Logger;\n  threadDispatcher: CustomUseReducerDispatcher;\n}\n\nexport default function useGetNextThreadsCallback({\n  hasMoreNext,\n  parentMessage,\n  threadListState,\n  latestMessageTimeStamp,\n  isReactionEnabled,\n}: DynamicProps, {\n  logger,\n  threadDispatcher,\n}: StaticProps): (callback: (messages?: Array<BaseMessage>) => void) => void {\n  return useCallback((callback) => {\n    // validation check\n    if (threadListState === ThreadListStateTypes.INITIALIZED\n      && parentMessage?.getThreadedMessagesByTimestamp\n      && latestMessageTimeStamp !== 0\n    ) {\n      threadDispatcher({\n        type: ThreadContextActionTypes.GET_NEXT_MESSAGES_START,\n        payload: null,\n      });\n      parentMessage.getThreadedMessagesByTimestamp?.(\n        latestMessageTimeStamp,\n        {\n          prevResultSize: 0,\n          nextResultSize: NEXT_THREADS_FETCH_SIZE,\n          includeReactions: isReactionEnabled,\n          includeMetaArray: true,\n        } as ThreadedMessageListParams,\n      )\n        .then(({ parentMessage, threadedMessages }) => {\n          logger.info('Thread | useGetNextThreadsCallback: Fetch next threads succeeded.', { parentMessage, threadedMessages });\n          threadDispatcher({\n            type: ThreadContextActionTypes.GET_NEXT_MESSAGES_SUCESS,\n            payload: { parentMessage, threadedMessages },\n          });\n          callback(threadedMessages);\n        })\n        .catch((error) => {\n          logger.info('Thread | useGetNextThreadsCallback: Fetch next threads failed.', error);\n          threadDispatcher({\n            type: ThreadContextActionTypes.GET_NEXT_MESSAGES_FAILURE,\n            payload: error,\n          });\n        });\n    }\n  }, [\n    hasMoreNext,\n    parentMessage,\n    threadListState,\n    latestMessageTimeStamp,\n  ]);\n}\n","import { GroupChannel } from '@sendbird/chat/groupChannel';\nimport { useCallback } from 'react';\nimport { Logger } from '../../../../lib/SendbirdState';\n\ninterface DynamicProps {\n  currentChannel: GroupChannel;\n}\ninterface StaticProps {\n  logger: Logger;\n}\n\nexport default function useToggleReactionCallback({\n  currentChannel,\n}: DynamicProps, {\n  logger,\n}: StaticProps): (message, key, isReacted) => void {\n  return useCallback((message, key, isReacted) => {\n    if (isReacted) {\n      currentChannel?.deleteReaction?.(message, key)\n        .then((res) => {\n          logger.info('Thread | useToggleReactionsCallback: Delete reaction succeeded.', res);\n        })\n        .catch((err) => {\n          logger.warning('Thread | useToggleReactionsCallback: Delete reaction failed.', err);\n        });\n      return;\n    }\n    currentChannel?.addReaction?.(message, key)\n      .then((res) => {\n        logger.info('Thread | useToggleReactionsCallback: Add reaction succeeded.', res);\n      })\n      .catch((err) => {\n        logger.warning('Thread | useToggleReactionsCallback: Add reaction failed.', err);\n      });\n  }, [currentChannel]);\n}\n","import { useCallback } from 'react';\nimport { GroupChannel } from '@sendbird/chat/groupChannel';\nimport { UserMessageCreateParams } from '@sendbird/chat/message';\n\nimport { CustomUseReducerDispatcher, Logger } from '../../../../lib/SendbirdState';\nimport { ThreadContextActionTypes } from '../dux/actionTypes';\nimport topics from '../../../../lib/pubSub/topics';\n\ninterface DynamicProps {\n  isMentionEnabled: boolean;\n  currentChannel: GroupChannel;\n}\ninterface StaticProps {\n  logger: Logger;\n  pubSub: any;\n  threadDispatcher: CustomUseReducerDispatcher;\n}\n\nexport default function useSendUserMessageCallback({\n  isMentionEnabled,\n  currentChannel,\n}: DynamicProps, {\n  logger,\n  pubSub,\n  threadDispatcher,\n}: StaticProps): (props) => void {\n  const sendMessage = useCallback((props) => {\n    const {\n      message,\n      quoteMessage = null,\n      mentionTemplate,\n      mentionedUsers,\n    } = props;\n    const createDefaultParams = () => {\n      const params = {} as UserMessageCreateParams;\n      params.message = message;\n      if (isMentionEnabled && mentionedUsers?.length > 0) {\n        params.mentionedUsers = mentionedUsers;\n      }\n      if (isMentionEnabled && mentionTemplate && mentionedUsers?.length > 0) {\n        params.mentionedMessageTemplate = mentionTemplate;\n      }\n      if (quoteMessage) {\n        params.isReplyToChannel = true;\n        params.parentMessageId = quoteMessage.messageId;\n      }\n      return params;\n    };\n\n    const params = createDefaultParams();\n    logger.info('Thread | useSendUserMessageCallback: Sending user message start.', params);\n\n    if (currentChannel?.sendUserMessage) {\n      currentChannel?.sendUserMessage(params)\n        .onPending((pendingMessage) => {\n          threadDispatcher({\n            type: ThreadContextActionTypes.SEND_MESSAGE_START,\n            payload: { message: pendingMessage },\n          });\n        })\n        .onFailed((error, message) => {\n          logger.info('Thread | useSendUserMessageCallback: Sending user message failed.', { message, error });\n          threadDispatcher({\n            type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n            payload: { error, message },\n          });\n        })\n        .onSucceeded((message) => {\n          logger.info('Thread | useSendUserMessageCallback: Sending user message succeeded.', message);\n          threadDispatcher({\n            type: ThreadContextActionTypes.SEND_MESSAGE_SUCESS,\n            payload: { message },\n          });\n          // because Thread doesn't subscribe SEND_USER_MESSAGE\n          pubSub.publish(topics.SEND_USER_MESSAGE, {\n            channel: currentChannel,\n            message: message,\n          });\n        });\n    }\n  }, [isMentionEnabled, currentChannel]);\n  return sendMessage;\n}\n","import { GroupChannel } from '@sendbird/chat/groupChannel';\nimport { FileMessage, MessageType, SendingStatus, UserMessage } from '@sendbird/chat/message';\nimport { useCallback } from 'react';\nimport { CustomUseReducerDispatcher, Logger } from '../../../../lib/SendbirdState';\nimport { ThreadContextActionTypes } from '../dux/actionTypes';\nimport topics from '../../../../lib/pubSub/topics';\n\ninterface DynamicProps {\n  currentChannel: GroupChannel;\n}\ninterface StaticProps {\n  logger: Logger;\n  pubSub: any;\n  threadDispatcher: CustomUseReducerDispatcher;\n}\n\nexport default function useResendMessageCallback({\n  currentChannel,\n}: DynamicProps, {\n  logger,\n  pubSub,\n  threadDispatcher,\n}: StaticProps): (failedMessage: UserMessage | FileMessage) => void {\n  return useCallback((failedMessage: UserMessage | FileMessage) => {\n    if ((failedMessage as UserMessage | FileMessage)?.isResendable) {\n      failedMessage.sendingStatus = SendingStatus.PENDING;\n      logger.info('Thread | useResendMessageCallback: Resending failedMessage start.', failedMessage);\n      threadDispatcher({\n        type: ThreadContextActionTypes.RESEND_MESSAGE_START,\n        payload: failedMessage,\n      });\n\n      if (failedMessage?.isUserMessage?.() || failedMessage?.messageType === MessageType.USER) {\n        currentChannel?.resendUserMessage(failedMessage as UserMessage)\n          .then((message) => {\n            logger.info('Thread | useResendMessageCallback: Resending failedMessage succeeded.', message);\n            threadDispatcher({\n              type: ThreadContextActionTypes.SEND_MESSAGE_SUCESS,\n              payload: { message },\n            });\n            pubSub.publish(topics.SEND_USER_MESSAGE, {\n              channel: currentChannel,\n              message: message,\n            });\n          })\n          .catch((error) => {\n            logger.warning('Thread | useResendMessageCallback: Resending failedMessage failed.', error);\n            failedMessage.sendingStatus = SendingStatus.FAILED;\n            threadDispatcher({\n              type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n              payload: { message: failedMessage },\n            });\n          });\n      } else if (failedMessage?.isFileMessage?.() || failedMessage?.messageType === MessageType.FILE) {\n        currentChannel?.resendFileMessage?.(failedMessage as FileMessage)\n          .then((message) => {\n            logger.info('Thread | useResendMessageCallback: Resending failedMessage succeeded.', message);\n            threadDispatcher({\n              type: ThreadContextActionTypes.SEND_MESSAGE_SUCESS,\n              payload: { message },\n            });\n          })\n          .catch((error) => {\n            logger.warning('Thread | useResendMessageCallback: Resending failedMessage failed.', error);\n            failedMessage.sendingStatus = SendingStatus.FAILED;\n            threadDispatcher({\n              type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n              payload: { message: failedMessage },\n            });\n            pubSub.publish(topics.SEND_FILE_MESSAGE, {\n              channel: currentChannel,\n              message: failedMessage,\n            });\n          });\n      } else {\n        logger.warning('Thread | useResendMessageCallback: Message is not resendable.', failedMessage);\n        failedMessage.sendingStatus = SendingStatus.FAILED;\n        threadDispatcher({\n          type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n          payload: { message: failedMessage },\n        });\n      }\n    }\n  }, [currentChannel]);\n}\n","import { useCallback } from 'react';\nimport { GroupChannel } from '@sendbird/chat/groupChannel';\nimport { FileMessage, FileMessageCreateParams, MessageMetaArray, UserMessage } from '@sendbird/chat/message';\nimport { CustomUseReducerDispatcher, Logger } from '../../../../lib/SendbirdState';\nimport { ThreadContextActionTypes } from '../dux/actionTypes';\nimport topics from '../../../../lib/pubSub/topics';\nimport { scrollIntoLast } from '../utils';\nimport {\n  META_ARRAY_MESSAGE_TYPE_KEY,\n  META_ARRAY_MESSAGE_TYPE_VALUE__VOICE,\n  META_ARRAY_VOICE_DURATION_KEY,\n  VOICE_MESSAGE_FILE_NAME,\n  VOICE_MESSAGE_MIME_TYPE,\n} from '../../../../utils/consts';\n\ninterface DynamicParams {\n  currentChannel: GroupChannel;\n  onBeforeSendVoiceMessage?: (file: File, quoteMessage?: UserMessage | FileMessage) => FileMessageCreateParams;\n}\ninterface StaticParams {\n  logger: Logger;\n  pubSub: any;\n  threadDispatcher: CustomUseReducerDispatcher;\n}\ntype FuncType = (file: File, duration: number, quoteMessage: UserMessage | FileMessage) => void;\ninterface LocalFileMessage extends FileMessage {\n  localUrl: string;\n  file: File;\n}\n\nexport const useSendVoiceMessageCallback = ({\n  currentChannel,\n  onBeforeSendVoiceMessage,\n}: DynamicParams,\n{\n  logger,\n  pubSub,\n  threadDispatcher,\n}: StaticParams): FuncType => {\n  const sendMessage = useCallback((file: File, duration: number, quoteMessage: UserMessage | FileMessage) => {\n    const messageParams: FileMessageCreateParams = (\n      onBeforeSendVoiceMessage\n      && typeof onBeforeSendVoiceMessage === 'function'\n    )\n      ? onBeforeSendVoiceMessage(file, quoteMessage)\n      : {\n        file,\n        fileName: VOICE_MESSAGE_FILE_NAME,\n        mimeType: VOICE_MESSAGE_MIME_TYPE,\n        metaArrays: [\n          new MessageMetaArray({\n            key: META_ARRAY_VOICE_DURATION_KEY,\n            value: [`${duration}`],\n          }),\n          new MessageMetaArray({\n            key: META_ARRAY_MESSAGE_TYPE_KEY,\n            value: [META_ARRAY_MESSAGE_TYPE_VALUE__VOICE],\n          }),\n        ],\n      };\n    if (quoteMessage) {\n      messageParams.isReplyToChannel = true;\n      messageParams.parentMessageId = quoteMessage.messageId;\n    }\n    logger.info('Thread | useSendVoiceMessageCallback:  Start sending voice message', messageParams);\n    currentChannel?.sendFileMessage(messageParams)\n      .onPending((pendingMessage) => {\n        threadDispatcher({\n          type: ThreadContextActionTypes.SEND_MESSAGE_START,\n          payload: {\n            /* pubSub is used instead of messagesDispatcher\n            to avoid redundantly calling `messageActionTypes.SEND_MESSAGEGE_START` */\n            message: {\n              ...pendingMessage,\n              url: URL.createObjectURL(file),\n              // pending thumbnail message seems to be failed\n              requestState: 'pending',\n            },\n          },\n        });\n        setTimeout(() => scrollIntoLast(), 1000);\n      })\n      .onFailed((error, message) => {\n        (message as LocalFileMessage).localUrl = URL.createObjectURL(file);\n        (message as LocalFileMessage).file = file;\n        logger.info('Thread | useSendVoiceMessageCallback: Sending voice message failed.', { message, error });\n        threadDispatcher({\n          type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n          payload: { message, error },\n        });\n      })\n      .onSucceeded((message) => {\n        logger.info('Thread | useSendVoiceMessageCallback: Sending voice message succeeded.', message);\n        pubSub.publish(topics.SEND_FILE_MESSAGE, {\n          channel: currentChannel,\n          message: message,\n        });\n      });\n  }, [\n    currentChannel,\n    onBeforeSendVoiceMessage,\n  ]);\n  return sendMessage;\n};\n\nexport default useSendVoiceMessageCallback;\n","import React, { useReducer, useMemo, useEffect, ReactElement } from 'react';\nimport { User } from '@sendbird/chat';\nimport { GroupChannel } from '@sendbird/chat/groupChannel';\nimport { BaseMessage, FileMessage, FileMessageCreateParams, UserMessage } from '@sendbird/chat/message';\n\nimport { getNicknamesMapFromMembers, getParentMessageFrom } from './utils';\nimport { UserProfileProvider } from '../../../lib/UserProfileContext';\nimport { CustomUseReducerDispatcher } from '../../../lib/SendbirdState';\nimport useSendbirdStateContext from '../../../hooks/useSendbirdStateContext';\n\nimport threadReducer from './dux/reducer';\nimport { ThreadContextActionTypes } from './dux/actionTypes';\nimport threadInitialState, { ThreadContextInitialState } from './dux/initialState';\n\nimport useGetChannel from './hooks/useGetChannel';\nimport useGetAllEmoji from './hooks/useGetAllEmoji';\nimport useGetThreadList from './hooks/useGetThreadList';\nimport useGetParentMessage from './hooks/useGetParentMessage';\nimport useHandlePubsubEvents from './hooks/useHandlePubsubEvents';\nimport useHandleChannelEvents from './hooks/useHandleChannelEvents';\nimport useSendFileMessageCallback from './hooks/useSendFileMessage';\nimport useUpdateMessageCallback from './hooks/useUpdateMessageCallback';\nimport useDeleteMessageCallback from './hooks/useDeleteMessageCallback';\nimport useGetPrevThreadsCallback from './hooks/useGetPrevThreadsCallback';\nimport useGetNextThreadsCallback from './hooks/useGetNextThreadsCallback';\nimport useToggleReactionCallback from './hooks/useToggleReactionsCallback';\nimport useSendUserMessageCallback from './hooks/useSendUserMessageCallback';\nimport useResendMessageCallback from './hooks/useResendMessageCallback';\nimport useSendVoiceMessageCallback from './hooks/useSendVoiceMessageCallback';\n\nexport type ThreadProviderProps = {\n  children?: React.ReactElement;\n  channelUrl: string;\n  message: UserMessage | FileMessage | null;\n  onHeaderActionClick?: () => void;\n  onMoveToParentMessage?: (props: { message: UserMessage | FileMessage, channel: GroupChannel }) => void;\n  onBeforeSendVoiceMessage?: (file: File, quotedMessage?: UserMessage | FileMessage) => FileMessageCreateParams;\n  // User Profile\n  disableUserProfile?: boolean;\n  renderUserProfile?: (props: { user: User, close: () => void }) => ReactElement;\n  onUserProfileMessage?: (channel: GroupChannel) => void;\n};\nexport interface ThreadProviderInterface extends ThreadProviderProps, ThreadContextInitialState {\n  // hooks for fetching threads\n  fetchPrevThreads: (callback?: (messages?: Array<BaseMessage>) => void) => void;\n  fetchNextThreads: (callback?: (messages?: Array<BaseMessage>) => void) => void;\n  toggleReaction: (message, key, isReacted) => void;\n  sendMessage: (props: {\n    message: UserMessage,\n    quoteMessage?: UserMessage | FileMessage,\n    mentionTemplate?: string,\n    mentionedUsers?: Array<User>,\n  }) => void;\n  sendFileMessage: (file: File, quoteMessage: UserMessage | FileMessage) => void;\n  sendVoiceMessage: (file: File, duration: number, quoteMessage?: UserMessage | FileMessage) => void;\n  resendMessage: (failedMessage: UserMessage | FileMessage) => void;\n  updateMessage: (props, callback?: () => void) => void;\n  deleteMessage: (message: UserMessage | FileMessage) => Promise<UserMessage | FileMessage>;\n  nicknamesMap: Map<string, string>;\n}\nconst ThreadContext = React.createContext<ThreadProviderInterface | null>(null);\n\nexport const ThreadProvider: React.FC<ThreadProviderProps> = (props: ThreadProviderProps) => {\n  const {\n    children,\n    channelUrl,\n    onHeaderActionClick,\n    onMoveToParentMessage,\n    onBeforeSendVoiceMessage,\n    // User Profile\n    disableUserProfile,\n    renderUserProfile,\n    onUserProfileMessage,\n  } = props;\n  const propsMessage = props?.message;\n  const propsParentMessage = getParentMessageFrom(propsMessage);\n  // Context from SendbirdProvider\n  const globalStore = useSendbirdStateContext();\n  const { stores, config } = globalStore;\n  // // stores\n  const { sdkStore, userStore } = stores;\n  const { sdk } = sdkStore;\n  const { user } = userStore;\n  const sdkInit = sdkStore?.initialized;\n  // // config\n  const {\n    logger,\n    pubSub,\n    replyType,\n    isMentionEnabled,\n    isReactionEnabled,\n  } = config;\n\n  // dux of Thread\n  const [threadStore, threadDispatcher] = useReducer(\n    threadReducer,\n    threadInitialState,\n  ) as [ThreadContextInitialState, CustomUseReducerDispatcher];\n  const {\n    currentChannel,\n    allThreadMessages,\n    parentMessage,\n    channelState,\n    threadListState,\n    parentMessageState,\n    hasMorePrev,\n    hasMoreNext,\n    emojiContainer,\n    isMuted,\n    isChannelFrozen,\n    currentUserId,\n  }: ThreadContextInitialState = threadStore;\n\n  // Initialization\n  useEffect(() => {\n    threadDispatcher({\n      type: ThreadContextActionTypes.INIT_USER_ID,\n      payload: user?.userId,\n    });\n  }, [user]);\n  useGetChannel({\n    channelUrl,\n    sdkInit,\n    message: propsMessage,\n  }, { sdk, logger, threadDispatcher });\n  useGetParentMessage({\n    channelUrl,\n    sdkInit,\n    parentMessage: propsParentMessage,\n  }, { sdk, logger, threadDispatcher });\n  useGetThreadList({\n    sdkInit,\n    parentMessage,\n    isReactionEnabled,\n    anchorMessage: propsMessage?.messageId !== propsParentMessage?.messageId ? propsMessage : null,\n    // anchorMessage should be null when parentMessage doesn't exist\n  }, { logger, threadDispatcher });\n  useGetAllEmoji({ sdk }, { logger, threadDispatcher });\n  // Handle channel events\n  useHandleChannelEvents({\n    sdk,\n    currentChannel,\n  }, { logger, threadDispatcher });\n  useHandlePubsubEvents({\n    sdkInit,\n    currentChannel,\n    parentMessage,\n  }, { logger, pubSub, threadDispatcher });\n\n  // callbacks\n  const fetchPrevThreads = useGetPrevThreadsCallback({\n    hasMorePrev,\n    parentMessage,\n    threadListState,\n    isReactionEnabled,\n    oldestMessageTimeStamp: allThreadMessages[0]?.createdAt || 0,\n  }, { logger, threadDispatcher });\n  const fetchNextThreads = useGetNextThreadsCallback({\n    hasMoreNext,\n    parentMessage,\n    threadListState,\n    isReactionEnabled,\n    latestMessageTimeStamp: allThreadMessages[allThreadMessages.length - 1]?.createdAt || 0,\n  }, { logger, threadDispatcher });\n  const toggleReaction = useToggleReactionCallback({ currentChannel }, { logger });\n  const sendMessage = useSendUserMessageCallback({\n    isMentionEnabled,\n    currentChannel,\n  }, { logger, pubSub, threadDispatcher });\n  const sendFileMessage = useSendFileMessageCallback({\n    currentChannel,\n  }, { logger, pubSub, threadDispatcher });\n  const sendVoiceMessage = useSendVoiceMessageCallback({\n    currentChannel, onBeforeSendVoiceMessage,\n  }, { logger, pubSub, threadDispatcher });\n  const resendMessage = useResendMessageCallback({\n    currentChannel,\n  }, { logger, pubSub, threadDispatcher });\n  const updateMessage = useUpdateMessageCallback({\n    currentChannel,\n    isMentionEnabled,\n  }, { logger, pubSub, threadDispatcher });\n  const deleteMessage = useDeleteMessageCallback({ currentChannel, threadDispatcher }, { logger });\n\n  // memo\n  const nicknamesMap: Map<string, string> = useMemo(() => (\n    (replyType && currentChannel)\n      ? getNicknamesMapFromMembers(currentChannel?.members)\n      : new Map()\n  ), [currentChannel?.members]);\n\n  return (\n    <ThreadContext.Provider\n      value={{\n        // ThreadProviderProps\n        channelUrl,\n        message: propsMessage,\n        onHeaderActionClick,\n        onMoveToParentMessage,\n        // ThreadContextInitialState\n        currentChannel,\n        allThreadMessages,\n        parentMessage,\n        channelState,\n        threadListState,\n        parentMessageState,\n        hasMorePrev,\n        hasMoreNext,\n        emojiContainer,\n        // hooks\n        fetchPrevThreads,\n        fetchNextThreads,\n        toggleReaction,\n        sendMessage,\n        sendFileMessage,\n        sendVoiceMessage,\n        resendMessage,\n        updateMessage,\n        deleteMessage,\n        // context\n        nicknamesMap,\n        isMuted,\n        isChannelFrozen,\n        currentUserId,\n      }}\n    >\n      {/* UserProfileProvider */}\n      <UserProfileProvider\n        disableUserProfile={disableUserProfile}\n        renderUserProfile={renderUserProfile}\n        onUserProfileMessage={onUserProfileMessage}\n      >\n        {children}\n      </UserProfileProvider>\n    </ThreadContext.Provider>\n  );\n};\n\nexport type UseThreadContextType = () => ThreadProviderInterface;\nexport const useThreadContext: UseThreadContextType = () => React.useContext(ThreadContext);\n"]},"metadata":{},"sourceType":"module"}